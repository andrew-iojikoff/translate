<!DOCTYPE html>
<html>
<head>
<title>v1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="-python-numpy-matplotlib-pandas-seaborn">Построение гистограмм в Python: NumPy, Matplotlib, Pandas &amp; Seaborn</h1>
<p>Из этого руководства вы получите знания, которые позволят вам делать качественные, готовые к презентации графики гистограмм в Python с различными вариантами представлений и другими возможностями.</p>
<p>Если у вас есть начальные знания о программировании в Python, а также в области математической статистики, то вы можете использовать эту статью как универсальный справочник для расчета и визуализации гистограмм в Python, используя библиотеки из научного стека, такие как <em>NumPy</em>, <em>Matplotlib</em>, <em>Pandas</em> и <em>Seaborn</em>.</p>
<p>Гистограмма - отличный инструмент для быстрой оценки распределения вероятностей, который интуитивно понятен любой компетентной аудитории. Python предлагает несколько различных вариантов расчета и построения гистограмм. Большинство людей знают гистограмму по ее графическому представлению, которое похоже на столбцевую диаграмму:</p>
<p>!!! рисунок</p>
<p>Эта статья поможет вам создать графики, подобные приведенным выше, а также более сложные. Вот что мы рассмотрим в этом руководстве:</p>
<ul>
<li>Создание гистограмм в чистом Python без использования сторонних библиотек;</li><li>Расчет     гистограмм с помощью <em>NumPy</em>, обрабатывая данные непосредственно;</li><li>Построение рассчитанной гистограммы с помощью <em>Matplotlib</em>, <em>Pandas</em> и <em>Seaborn</em></li></ul>
<h2 id="-python">Гистограммы на чистом Python</h2>
<p>Когда вы готовитесь к построению гистограммы, проще всего не думать об составе данных, необходимо просто рассчитать, сколько раз появляется каждое значение в заданном наборе данных (таблица частот). Такой тип данных как словарь <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionary</a> в Python хорошо подходит для задачи хранения полученных результатов:</p>
<pre><code>&gt;&gt;&gt; # Need not be sorted, necessarily
&gt;&gt;&gt; a = (0, 1, 1, 1, 2, 3, 7, 7, 23)

&gt;&gt;&gt; def count_elements(seq) -&gt; dict:
...     &quot;&quot;&quot;Tally elements from `seq`.&quot;&quot;&quot;
...     hist = {}
...     for i in seq:
...         hist[i] = hist.get(i, 0) + 1
...     return hist

&gt;&gt;&gt; counted = count_elements(a)
&gt;&gt;&gt; counted
{0: 1, 1: 3, 2: 1, 3: 1, 7: 2, 23: 1}
</code></pre><p>функция <em>count_elements()</em> возвращает словарь с уникальными элементами из последовательности <em>seq</em> в качестве ключей и соответствующих им частот (количество появлений в последовательности), как соответствующих этим ключам значениям. Перебираем в цикле последовательность <em>seq</em>, инструкция означает <em>hist[i] = hist.get(i, 0) + 1</em> для каждого элемента из входной последовательности увеличить на единицу значение рассчитываемой гистограммы <em>hist</em> с соответствующим ключом.<br>Фактически, это именно то, что делается с использованием класса <em>collections.Counter</em> из стандартной библиотеки, который является подклассом <a href="https://github.com/python/cpython/blob/7f1bcda9bc3c04100cb047373732db0eba00e581/Lib/collections/__init__.py#L466">subclasses</a> словаря Python и переопределяет его метод <em>.update()</em>:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; recounted = Counter(a)
&gt;&gt;&gt; recounted
Counter({0: 1, 1: 3, 3: 1, 2: 1, 7: 2, 23: 1})
</code></pre><p>Вы можете видеть, что ваша функция <em>count_elements</em> делает практически то же самое, что и collections.Counter, проверим эквивалентность двух последовательностей:</p>
<pre><code>&gt;&gt;&gt; recounted.items() == counted.items()
True
</code></pre><blockquote>
<p><strong>Техническая справка</strong>: Преобразование с использованием <em>count_elements()</em> может быть по умолчанию оптимизировано с помощью Си-функции <a href="https://github.com/python/cpython/blob/a5c42284e69fb309bdd17ee8c1c120d1be383012/Modules/_collectionsmodule.c#L2250">C function</a> если это возможно использовать. Код Python внутри функции <em>count_elements()</em> можно оптимизировать следующим образом: объявить переменную <em>get = hist.get</em> перед циклом. Это свяжет метод с переменной для более быстрых вызовов внутри цикла.<br>Вам может быть полезно создать такие упрощенные функции самим, как первый шаг к пониманию более сложных. Давайте еще еще раз изобретем с гистограммой в виде символов ASCII, которая использует возможности Python по форматированному выводу данных <a href="https://docs.python.org/tutorial/inputoutput.html#fancier-output-formatting">output formatting</a>: </p>
</blockquote>
<pre><code>def ascii_histogram(seq) -&gt; None:
    &quot;&quot;&quot;A horizontal frequency-table/histogram plot.&quot;&quot;&quot;
    counted = count_elements(seq)
    for k in sorted(counted):
        print(&#39;{0:5d} {1}&#39;.format(k, &#39;+&#39; * counted[k]))
</code></pre><p>Эта функция создает отсортированную частотную диаграмму, в которой значения рассчитанных частот гистограммы представлены в виде соответствующего числа символов плюс (+). Вызов функции <em>sorted()</em> для словаря (рассчитанной гистограммы) возвращает отсортированный по его ключам список. Также вы можете создать несколько больший набор данных с помощью модуля Python <em>random</em>: </p>
<pre><code>&gt;&gt;&gt; # No NumPy ... yet
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.seed(1)

&gt;&gt;&gt; vals = [1, 3, 4, 6, 8, 9, 10]
&gt;&gt;&gt; # Each number in `vals` will occur between 5 and 15 times.
&gt;&gt;&gt; freq = (random.randint(5, 15) for _ in vals)

&gt;&gt;&gt; data = []
&gt;&gt;&gt; for f, v in zip(freq, vals):
...     data.extend([v] * f)

&gt;&gt;&gt; ascii_histogram(data)
    1 +++++++
    3 ++++++++++++++
    4 ++++++
    6 +++++++++
    8 ++++++
    9 ++++++++++++
   10 ++++++++++++
</code></pre><blockquote>
<p><strong>Примечение</strong>: метод <a href="https://docs.python.org/library/random.html#random.seed">random.seed()</a> используется для инициации и инициализации генератора псевдослучайных чисел <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">PRNG</a> являющегося основой используемого модуля <em>random</em>. Это может звучать как оксюморон, но это метод сделает случайные данные воспроизводимыми и детерминированными. То есть, если вы скопируете весь наш код как есть, вы должны получить точно такую ​​же гистограмму, потому что первый вызов <em>random.randint()</em> после инициализации генератора будет генерировать идентичные «случайные» данные с использованием <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a>.</p>
</blockquote>
<h2 id="-numpy">Создание базы: вычислением гистограммы используя NumPy</h2>
<p>До сих пор вы работали над тем, что лучше всего назвать «таблицами частот». Но математически гистограмма представляет собой отображение частот на интервалы значений. Технически это может быть использовано для аппроксимации функции плотности вероятности <a href="https://en.wikipedia.org/wiki/Probability_density_function">PDF</a> случайной величины.<br>Переходя от «таблицы частот» к настоящей гистограмме берут диапазон значений, а затем подсчитывают количество значений, которые попадают в этот интервал. Это то, что делает функция для гистограмм <em>histogram()</em> из NumPy, и она является основой для других функций, с которыми вы ознакомитесь здесь ниже в таких библиотеках Python, как Matplotlib и Pandas.</p>
<p>Рассмотрим набор чисел в формате <em>float</em> (вещественных чисел с плавающей запятой), со случайным распределением Лапласа <a href="https://en.wikipedia.org/wiki/Laplace_distribution">Laplace distribution</a>. Кривая плотности вероятности этого распределения имеет более пологие скаты, чем нормального распределения, и имеет два описательных параметра (сдвиг и масштаб):</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; # `numpy.random` uses its own PRNG.
&gt;&gt;&gt; np.random.seed(444)
&gt;&gt;&gt; np.set_printoptions(precision=3)

&gt;&gt;&gt; d = np.random.laplace(loc=15, scale=3, size=500)
&gt;&gt;&gt; d[:5]
array([18.406, 18.087, 16.004, 16.221,  7.358])
</code></pre><p>В этом случае вы работаете с непрерывным распределением, и было бы не очень рационально рассчитывать значение частоты для каждого значения <em>float</em> отдельно, вплоть до десятизначного знака после запятой. Вместо этого вы можете загружать данные и подсчитывать результаты наблюдений, которые попадают в каждый интервал. Гистограмма - это результат подсчета количества значений внутри каждого интервала:</p>
<pre><code>&gt;&gt;&gt; hist, bin_edges = np.histogram(d)

&gt;&gt;&gt; hist
array([ 1,  0,  3,  4,  4, 10, 13,  9,  2,  4])

&gt;&gt;&gt; bin_edges
array([ 3.217,  5.199,  7.181,  9.163, 11.145, 13.127, 15.109, 17.091,
       19.073, 21.055, 23.037])
</code></pre><p>Этот результат может быть не сразу интуитивно понятен. <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html">np.histogram()</a> по умолчанию использует 10 одинаковых диапазонов значений и возвращает кортеж счетчиков частоты и соответствующих им концов диапазона. Они являются концами интервалов в том смысле, что их на один больше, чем число диапазонов значений рассчитанной гистограммы:</p>
<pre><code>&gt;&gt;&gt; hist.size, bin_edges.size
(10, 11)
</code></pre><blockquote>
<p><strong>Техническая справка</strong>: Все рассчитанные интервалы данных, кроме последнего (самого правого), полуоткрыты. То есть все интервалы, кроме последнего [включительно, исключительно], являются открытыми [включительно, включительно].</p>
</blockquote>
<p>Очень сжатая разбивка на интервалы построенная с помощью NumPy, выглядит так:</p>
<pre><code>&gt;&gt;&gt; # The leftmost and rightmost bin edges
&gt;&gt;&gt; first_edge, last_edge = a.min(), a.max()

&gt;&gt;&gt; n_equal_bins = 10  # NumPy&#39;s default
&gt;&gt;&gt; bin_edges = np.linspace(start=first_edge, stop=last_edge,
...                         num=n_equal_bins + 1, endpoint=True)
...
&gt;&gt;&gt; bin_edges
array([ 0. ,  2.3,  4.6,  6.9,  9.2, 11.5, 13.8, 16.1, 18.4, 20.7, 23. ])
</code></pre><p>Вышеприведенный случай имеет следующий смысл: 10 одинаково разнесенных в диапазоне от минимального (0) до максимального значения (23) интервалов с шириной 2,3.<br>Полученные данные передаются в функцию <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html">np.bincount()</a> или <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html">np.searchsorted()</a>. Функция <em>np.bincount()</em> сама может быть использована для создания «таблицы частот» с тем отличием, что значение с нулевым вхождением также включено по умолчанию:</p>
<pre><code>&gt;&gt;&gt; bcounts = np.bincount(a)
&gt;&gt;&gt; hist, _ = np.histogram(a, range=(0, a.max()), bins=a.max() + 1)

&gt;&gt;&gt; np.array_equal(hist, bcounts)
True

&gt;&gt;&gt; # Reproducing `collections.Counter`
&gt;&gt;&gt; dict(zip(np.unique(a), bcounts[bcounts.nonzero()]))
{0: 1, 1: 3, 2: 1, 3: 1, 7: 2, 23: 1}
</code></pre><blockquote>
<p><strong>Примечение</strong>: <em>hist</em> по умолчанию использует диапазоны шириной 1.0, а не «дискретные» отсчеты произвольной ширины. Следовательно, это работает только для подсчета вхождений целых чисел, а не для действительных чисел с плавающей точкой <em>float</em>, таких как [3.9, 4.1, 4.15].</p>
</blockquote>
<h2 id="-matplotlib-pandas">Визуализация гистограмм с помощью Matplotlib и Pandas</h2>
<p>Теперь, когда вы рассмотрели, как построить гистограмму на чистом Python с нуля, давайте посмотрим, как другие пакеты Python могут выполнить эту работу за нас. <a href="https://realpython.com/python-matplotlib-guide/">Matplotlib</a> обеспечивает обширную функциональность для визуализации гистограмм из коробки с гибкой оболочкой вокруг гистограмм рассчитанных с помощью <em>NumPy</em>:</p>
<pre><code>import matplotlib.pyplot as plt

# An &quot;interface&quot; to matplotlib.axes.Axes.hist() method
n, bins, patches = plt.hist(x=d, bins=&#39;auto&#39;, color=&#39;#0504aa&#39;,
                            alpha=0.7, rwidth=0.85)
plt.grid(axis=&#39;y&#39;, alpha=0.75)
plt.xlabel(&#39;Value&#39;)
plt.ylabel(&#39;Frequency&#39;)
plt.title(&#39;My Very Own Histogram&#39;)
plt.text(23, 45, r&#39;$\mu=15, b=3$&#39;)
maxfreq = n.max()
# Set a clean upper y-axis limit.
plt.ylim(ymax=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10)
</code></pre><p>!! рисунок</p>
<p>Как было определено ранее, для построения графика гистограммы используются рассчитанные заранее интервалы значений с заданными границами по оси <em>X</em>, и соответствующие им частоты по оси <em>Y</em>. При построении приведенного выше графика значение именованного аргумента <em>bins = &#39;auto&#39;</em>, что определяет выбор между двумя алгоритмами для оценки &quot;идеального&quot; количества интервалов для разбиения всего диапазона значений. В общем смысле целью выбранного алгоритма является определение ширины интервала, которая позволит наиболее точно представить выходные данные. Для получения дополнительной технической информации по этому вопросу, ознакомьтесь со статьей <a href="http://docs.astropy.org/en/stable/visualization/histogram.html">Выбор интервалов гистограмм (Choosing Histogram Bins) </a> из документации к <em>Astropy</em>. </p>
<p>Рассмотрим научный стек библиотек Python. Расчет гистограмм производится функцией из библиотеки Pandas <em>Series.histogram()</em>, для построения графика гистограммы используется функция <a href="https://github.com/pandas-dev/pandas/blob/cbec58eacd8e9cd94b7f42351b8de4559c250909/pandas/plotting/_core.py#L1310">matplotlib.pyplot.hist()</a> из библиотеки Matplotlib:</p>
<pre><code>import pandas as pd

# Generate data on commute times.
size, scale = 1000, 10
commutes = pd.Series(np.random.gamma(scale, size=size) ** 1.5)

commutes.plot.hist(grid=True, bins=20, rwidth=0.9,
                   color=&#39;#607c8e&#39;)
plt.title(&#39;Commute Times for 1,000 Commuters&#39;)
plt.xlabel(&#39;Counts&#39;)
plt.ylabel(&#39;Commute Time&#39;)
plt.grid(axis=&#39;y&#39;, alpha=0.75)
</code></pre><p><em>pandas.DataFrame.histogram()</em> аналогичен, но создает гистограмму для каждого столбца данных из DataFrame.</p>
<h2 id="-kde-">Вычисление оценки плотности ядра (KDE)</h2>
<p>В этом уроке мы работали с выборками данных, называемыми статистическими. Независимо от того, являются ли эти данные дискретными или непрерывными, предполагается, что они получены из выборки, которая достоверно имеет статистическое распределение, точно описываемое несколькими параметрами.<br>Оценка плотности ядра (KDE) является способом оценки функции плотности вероятности (PDF) случайной величины, которая лежит в основе нашей выборки данных. KDE применяется для сглаживания данных.<br>Используя библиотеку Pandas, вы можете создавать и накладывать друг на друга графики плотности вероятности, используя функцию <em>plot.kde()</em>, которая доступна для объектов <em>Series</em> и <em>DataFrame</em>. Но сначала давайте сгенерируем две разных выборки данных для сравнения:</p>
<pre><code>&gt;&gt;&gt; # Sample from two different normal distributions
&gt;&gt;&gt; means = 10, 20
&gt;&gt;&gt; stdevs = 4, 2
&gt;&gt;&gt; dist = pd.DataFrame(
...     np.random.normal(loc=means, scale=stdevs, size=(1000, 2)),
...     columns=[&#39;a&#39;, &#39;b&#39;])
&gt;&gt;&gt; dist.agg([&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;std&#39;]).round(decimals=2)
          a      b
min   -1.57  12.46
max   25.32  26.44
mean  10.12  19.94
std    3.94   1.94
</code></pre><p>Теперь, чтобы построим каждую гистограмму в той же системе координат, используя Matplotlib:</p>
<pre><code>fig, ax = plt.subplots()
dist.plot.kde(ax=ax, legend=False, title=&#39;Histogram: A vs. B&#39;)
dist.plot.hist(density=True, ax=ax)
ax.set_ylabel(&#39;Probability&#39;)
ax.grid(axis=&#39;y&#39;)
ax.set_facecolor(&#39;#d8dcd6&#39;)
</code></pre><p>!!! рисунок</p>
<p>Эти методы используют <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">gaussian_kde()</a> из библиотеки SciPy, что приводит к получению более плавного вида плотности вероятности распределения случайной величины (PDF). Если вы более подробно рассмотрите эту функцию, вы можете увидеть, насколько точно она аппроксимирует «истинную» плотность вероятности (PDF) для относительно небольшой выборки из 1000 отсчетов данных. Далее вы можете сначала построить «аналитическое» распределение с помощью <em>scipy.stats.norm()</em>. Это экземпляр класса, который инкапсулирует стандартное нормальное распределение, его моменты и другие описывающие функции. Его плотность вероятности (PDF) является «точным» в том смысле, что он определен точно выражением <em>norm.pdf (x) = exp (-x ** 2/2) / sqrt (2 </em> pi)<em>.<br>Используя это вы можете получить случайную выборку из 1000 отсчетов данных с помощью этой библиотеки, а затем попытаться произвести оценку плотности вероятности (PDF) с помощью метода </em>scipy.stats.gaussian_kde()*:</p>
<pre><code>from scipy import stats

# An object representing the &quot;frozen&quot; analytical distribution
# Defaults to the standard normal distribution, N~(0, 1)
dist = stats.norm()

# Draw random samples from the population you built above.
# This is just a sample, so the mean and std. deviation should
# be close to (1, 0).
samp = dist.rvs(size=1000)

# `ppf()`: percent point function (inverse of cdf — percentiles).
x = np.linspace(start=stats.norm.ppf(0.01),
                stop=stats.norm.ppf(0.99), num=250)
gkde = stats.gaussian_kde(dataset=samp)

# `gkde.evaluate()` estimates the PDF itself.
fig, ax = plt.subplots()
ax.plot(x, dist.pdf(x), linestyle=&#39;solid&#39;, c=&#39;red&#39;, lw=3,
        alpha=0.8, label=&#39;Analytical (True) PDF&#39;)
ax.plot(x, gkde.evaluate(x), linestyle=&#39;dashed&#39;, c=&#39;black&#39;, lw=2,
        label=&#39;PDF Estimated via KDE&#39;)
ax.legend(loc=&#39;best&#39;, frameon=False)
ax.set_title(&#39;Analytical vs. Estimated PDF&#39;)
ax.set_ylabel(&#39;Probability&#39;)
ax.text(-2., 0.35, r&#39;$f(x) = \frac{\exp(-x^2/2)}{\sqrt{2*\pi}}$&#39;,
        fontsize=12)
</code></pre><p>!!! рисунок</p>
<p>Это большой фрагмент кода, поэтому давайте затратим немного времени, для того чтобы более подробно рассмотреть несколько ключевых моментов:</p>
<ul>
<li>Статистический пакет библиотеки SciPy позволяет создавать объекты Python, представляющие собой аналитические распределения случайной величины различных видов, которые вы можете использовать для создания отсчетов данных. Таким образом <em>dist = stats.norm ()</em> представляет непрерывную случайную величину распределенную по нормальному закону, и вы можете генерировать случайные числа с помощью метода <em>dist.rvs()</em>.</li><li><p>Для оценки как аналитической плотности вероятности (PDF), так и гауссовской оценки плотности ядра (KDE) нам нужен массив <em>х</em> <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%B8%D0%BB%D1%8C">квантилей</a> (значение математического ожидания для нормального распределения плюс/минус величина соответствующяя среднеквадратическому отклонению). <em>stats.gaussian_kde()</em> предоставляет оценку плотности распределения вероятности (PDF), которую вам необходимо получить при обработке массива входных данных для нашего примера. </p>
</li><li><p>Последняя строка содержит выражение <a href="https://matplotlib.org/users/usetex.html">LaTex</a> для вывода математических формул, который прекрасно сочетается с Matplotlib.</p>
</li></ul>
<h2 id="-seaborn">Яркая альтернатива с Seaborn</h2>
<p>Давайте добавим еще один пакет Python в наш микс. У Seaborn есть функция <em>displot()</em>, которая строит график гистограммы и KDE для одномерного распределения за один шаг. Используя массив NumPy <em>d</em> из примера ранее:</p>
<pre><code>import seaborn as sns

sns.set_style(&#39;darkgrid&#39;)
sns.distplot(d)
</code></pre><p>!!! рисонок</p>
<p>Вызов указанной выше функции производит оценку плотности ядра (KDE). Существует также возможность задать вид закона распределения данных. Это отличается от оценки плотности ядра (KDE) и состоит из параметров для оценки общих данных и указания конкретного вида распределения:</p>
<pre><code>sns.distplot(d, fit=stats.laplace, kde=False)
</code></pre><p>!!! рисунок</p>
<p>Еще раз отметим небольшую разницу. В первом случае мы оцениваете неизвестную плотность распределения вероятности (PDF), во втором, мы принимаем данные с известным распределением и находим, какие параметры лучше всего описывают его, учитывая эмпирические данные.</p>
<h2 id="-pandas">Другие инструменты в Pandas</h2>
<p>В дополнение к рассмотренным инструментам построения графиков, Pandas также предлагает удобный метод <em>.value_counts()</em>, который вычисляет гистограмму ненулевых значений в <em>Series</em> Pandas:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; data = np.random.choice(np.arange(10), size=10000,
...                         p=np.linspace(1, 11, 10) / 60)
&gt;&gt;&gt; s = pd.Series(data)

&gt;&gt;&gt; s.value_counts()
9    1831
8    1624
7    1423
6    1323
5    1089
4     888
3     770
2     535
1     347
0     170
dtype: int64

&gt;&gt;&gt; s.value_counts(normalize=True).head()
9    0.1831
8    0.1624
7    0.1423
6    0.1323
5    0.1089
dtype: float64
</code></pre><p>Так же метод <em>pandas.cut()</em> является удобным способом для значений разбиения входных данных на произвольные интервалы. Допустим, у вас есть данные о возрасте людей и вы хотите их рационально отобрать их часть:</p>
<pre><code>&gt;&gt;&gt; ages = pd.Series(
...     [1, 1, 3, 5, 8, 10, 12, 15, 18, 18, 19, 20, 25, 30, 40, 51, 52])
&gt;&gt;&gt; bins = (0, 10, 13, 18, 21, np.inf)  # The edges
&gt;&gt;&gt; labels = (&#39;child&#39;, &#39;preteen&#39;, &#39;teen&#39;, &#39;military_age&#39;, &#39;adult&#39;)
&gt;&gt;&gt; groups = pd.cut(ages, bins=bins, labels=labels)

&gt;&gt;&gt; groups.value_counts()
child           6
adult           5
teen            3
military_age    2
preteen         1
dtype: int64

&gt;&gt;&gt; pd.concat((ages, groups), axis=1).rename(columns={0: &#39;age&#39;, 1: &#39;group&#39;})
    age         group
0     1         child
1     1         child
2     3         child
3     5         child
4     8         child
5    10         child
6    12       preteen
7    15          teen
8    18          teen
9    18          teen
10   19  military_age
11   20  military_age
12   25         adult
13   30         adult
14   40         adult
15   51         adult
16   52         adult
</code></pre><p>Приятно, что обе эти операции в конечном счете используют код <a href="https://github.com/pandas-dev/pandas/tree/master/pandas/_libs">Cython</a>, который делает их конкурентоспособными по скорости, сохраняя при этом их гибкость.</p>
<h2 id="-">Хорошо, так что я должен использовать?</h2>
<p>На данный момент мы рассмотрели на выбор больше, чем несколько функций и методов  для построения гистограмм в Python. Как их можно сравнить? Короче говоря, среди них нет универсальных. Ниже приведен список функций и методов, которые мы рассмотрели в этой статье, все они связаны с их возможностями по разбивке диапазона входных данных и представлением распределений в Python:</p>
<table>
<thead>
<tr>
<th>Имеем/хотим</th>
<th>Преимущества использования</th>
<th>Замечания</th>
</tr>
</thead>
<tbody>
<tr>
<td>Чистые целочисленные данные, размещенные в структурах данных Python, таких как список, кортеж или множество. И вы хотите создать гистограмму Python без импорта каких-либо сторонних библиотек.</td>
<td><a href="https://docs.python.org/3.6/library/collections.html#collections.Counter">collections.Counter()</a> из стандартной библиотеки Python предлагает быстрый и простой способ получить таблицу частот из контейнера данных.</td>
<td>Это таблица частот, и поэтому она не предполагает использования концепции гистограмм в полном объеме</td>
</tr>
<tr>
<td>Имеется большой массив данных, и вы хотите вычислить гистограмму, представляющую собой интервалы значений и соответствующие им частоты</td>
<td>Методы Numpy <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html">np.histogram()</a> и <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html">np.bincount()</a> полезны как для вычисления значений гистограммы численно, так и соответствующих интервалов для разбиения диапазона значений.</td>
<td>Для получения дополнительной информации ознакомьтесь с <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.digitize.html">np.digitize()</a>.</td>
</tr>
<tr>
<td>Табличные данные, запакованные в объекте Pandas <em>Series</em> или <em>DataFrame</em>.</td>
<td>Такие методы Pandas как <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.plot.hist.html">Series.plot.hist()</a>, <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.plot.hist.html">DataFrame.plot.hist()</a>, <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.value_counts.html">Series.value_counts()</a> и <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html">cut()</a>, а также <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.plot.kde.html">Series.plot.kde()</a> и <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.plot.kde.html">DataFrame.plot.kde()</a></td>
<td>Ознакомьтесь с <a href="https://pandas.pydata.org/pandas-docs/stable/visualization.html">документацией Pandas для визуализации данных</a> для вдохновения.</td>
</tr>
<tr>
<td>Создать красивый график с с большим числом гибких настроек из любой структуры данных.</td>
<td><a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html">pyplot.hist()</a> - широко используемая функция для построения гистограмм, которая использует метод <em>np.histogram()</em> и является основной функций построения графиков гистограмм в Pandas.</td>
<td>Matplotlib, представляет собой объектно-ориентированный фреймвок, который отлично подходит для тонкой настройки отдельных частей графика гистограммы. Изучение его интерфейса может занять определенное время для того чтобы полностью освоить его. Но в конечном итоге это позволит вам быть предельно точным в том, как в последствии будет выглядеть визуализация ваших данных.</td>
</tr>
<tr>
<td>Предварительно законченный дизайн и интеграция.</td>
<td>Метод Seaborn <a href="https://seaborn.pydata.org/generated/seaborn.distplot.html">distplot()</a> для объединения в один графиков гистограммы и расчитанной плотности ядра (KDE) или построения графика распределения случайной величины.</td>
<td>По сути, это «обертка вокруг обертки», которая использует рассчитанную гистограмму Matplotlib, которая, в свою очередь, использует NumPy.</td>
</tr>
</tbody>
</table>
<p>Удачи в расчете и построении графиков гистограмм в реальных проектах.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
