<h1 id="-import-python">Полное руководство по использованию инструкции <em>import</em> в языке Python</h1>
<p>Я почти никогда не мог с первого раза написать правильно такие инструкции Python как <code>import</code>. Поведение этой инструкции не одинаково в различных версиях Python 2.7 и Python 3.6 (эти две версии рассматриваются здесь) и нет единого способа сделать так, что бы инструкция импорта <code>import</code> всегда гарантированно работала так как нам нужно. Эта статья - погружение в решение проблем с использованием инструкции <code>import</code>.</p>
<h2 id="-">Общее / Ключевые моменты</h2>
<ul>
<li>инструкция <code>import</code> осуществляет поиск модулей в списке путей, содержащемся в переменной <code>sys.path</code>;</li><li><code>sys.path</code> всегда включает путь к скрипту, запущенному в настоящий момент времени в командной строке и однозначно задает рабочую директорию для текущего сеанса командной строки;</li><li>концептуально импорт пакета происходит, как импорт пакета с использованием файла <code>__init__.py</code>.</li></ul>
<h2 id="-">Основные определения</h2>
<ul>
<li><strong>модуль</strong>: любой файл с расширением <code>*.py</code>. Именем модуля является имя файла.</li><li><strong>встроенный модуль</strong>: &quot;модуль&quot; (написанный на С ), который интегрирован непосредственно в интерпретатор Python и следовательно не имеет файла с расширением <code>*.py</code>.</li><li><strong>пакет</strong>: любая папка содержащая файл с именем <code>__init\__.py</code>. Имя пакета совпадает с именем папки. В Python 3.3 и выше любая папка (даже без файла <code>__init\__.py</code>) считается пакетом. </li><li><strong>объект</strong>: в Python почти всё является объектом: функции, классы, переменные и т.д.</li></ul>
<h2 id="-">Пример структуры директории</h2>
<pre><code>test/                      # корневая папка
    packA/                 # пакет packA
        subA/              # субпакет subA
            __init__.py
            sa1.py
            sa2.py
        __init__.py
        a1.py
        a2.py
    packB/                 # пакет packB (неявное пространство имен пакета)
        b1.py
        b2.py
    math.py
    random.py
    other.py
    start.py
</code></pre><p>Обратите внимание, что мы не размещаем <code>__init\__.py</code> в корневой папке <code>test/</code>. </p>
<h2 id="-import-">Что такое <code>import</code> ?</h2>
<p>Когда вы импортируете модуль, Python запускает код в файле модуля. Когда вы импортируете пакет, Python запускает код в файле пакета <code>__init__.py</code>, если такой файл существует. После этого все объекты, определенные в файле модуля или <code>__init__.py</code> пакета, становятся доступны.</p>
<h2 id="-import-sys-path-">Основы использования оператора <code>import</code> и переменной <code>sys.path</code></h2>
<p>В соответствии с документацией Python, оператор <code>import</code> ищет корректный модуль или пакет для импорта следующим образом. </p>
<blockquote>
<p>Когда импортируется модуль с определенным именем, например <code>spam</code>, интерпретатор сначала ищет встроенный модуль с этим именем.<br>Если он не найден, он ищет файл с именем <code>spam.py</code> в списке каталогов, заданных в переменной <code>sys.path</code>. <code>sys.path</code> инициализируется следующими значениями  путей:</p>
<ul>
<li>директория, содержащая запущенный на исполнение скрипт (или текущий каталог, когда не указан файл).</li><li>переменная окружения PYTHONPATH (список имен каталогов с тем же синтаксисом, что и PATH переменная оболочки <code>shell</code>).</li><li>значение по умолчанию, заданное при установке Python.</li></ul>
<p>После запуска программы, написанные на Python, могут изменять значение переменной <code>sys.path</code>. Каталог, содержащий выполняемый скрипт, помещается в начало списка путей для поиска при импорте, впереди значения, содержащего путь к стандартной библиотеке.</p>
</blockquote>
<p>Технически документация Python является неполной. На самом деле интерпретатор ищет не только файл (то есть, модуль) с именем <code>spam.py</code>, также он будет искать папку (то есть, пакет) с именем <code>spam</code>.<br>Обратите внимание, что интерпретатор Python сначала ищет список встроенных модулей, то есть модулей, которые интегрированы непосредственно в интерпретатор Python. Состав списка встроенных модулей зависит от типа установки и может быть найден в файлах <code>sys.builtin_module_names</code> (для Python версии <a href="http://https://docs.python.org/2/tutorial/modules.html#the-module-search-path">2</a> и <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path">3</a>). Обычно встроенные модули, которые входят с состав начальной установки, включают в себя <code>sys</code> (всегда устанавливается), <code>math</code>, <code>itertools</code> и <code>time</code> и другие.</p>
<p>В отличие от встроенных модулей (модулей стандартной библиотеки), пути к которым помещаются первыми в списке для поиска при импорте остальные модули в стандартной библиотеке Python появляются после пути каталога текущего скрипта. Это приводит к запутанному поведению: становится возможно «заменить» некоторые, но не все модули в стандартной библиотеке Python.<br>Например, на моем компьютере (Windows 10, Python 3.6) модуль <code>math</code> является встроенным модулем, тогда как модуль <code>random</code> нет. Таким образом, <code>import math</code> в <code>start.py</code> будет импортировать модуль <code>math</code>  из стандартной библиотеки, а не мой собственный файл <code>math.py</code>, находящийся в тот же каталоге.<br>А оператор <code>import random</code> в <code>start.py</code> будет импортировать мой файл <code>random.py</code>, а не модуль <code>random</code> из стандартной библиотеки.</p>
<p>Кроме того, оператор <code>import</code> чувствителен к регистру символов в названии импортируемого файла. <code>import Spam</code> - это не то же самое, что <code>import spam</code>.</p>
<p>Функция <code>pkgutil.iter_modules</code> (Python <a href="https://docs.python.org/2/library/pkgutil.html#pkgutil.iter_modules">2</a> и <a href="https://docs.python.org/3/library/pkgutil.html#pkgutil.iter_modules">3</a>) может использоваться для получения списка всех импортируемых модулей по заданному пути:</p>
<pre><code>import pkgutil
search_path = &#39;.&#39; # set to None to see all modules importable from sys.path
all_modules = [x[1] for x in pkgutil.iter_modules(path=search_path)]
print(all_modules)
</code></pre><p>Источники:</p>
<ul>
<li><a href="https://stackoverflow.com/q/8370206">Как получить список встроенных модулей в python ?</a></li></ul>
<h2 id="-sys-path-">Подробнее о <code>sys.path</code></h2>
<p>Чтобы узнать, что находится в <code>sys.path</code>, запустите в интерпретаторе следующие команды или скрипт содержащий инструкции:</p>
<pre><code>import sys
print(sys.path)
</code></pre><p>Документация Python для <code>sys.path</code> описывает это следующим образом.</p>
<blockquote>
<p>Список строк, определяющий пути поиска для модулей, инициализируется из переменной среды PYTHONPATH, а также зависит от значений по умолчанию при установке.<br>В ходе инициализации при запуске программы Python, первым элементом этого списка <code>path[0]</code>, будет являться каталог, содержащий скрипт, который использовался при вызове интерпретатора Python.<br>Если каталог содержащий файл сценария недоступен (например, если интерпретатор работает в интерактивном режиме или если скрипт считывается в потоке стандартного ввода), <code>path[0]</code> - будет задан пустой строкой, которая  направляет Python на поиск модулей в текущем каталоге.<br>Обратите внимание, что путь к каталогу, содержащему файл сценария будет вставлен перед путями полученными из переменной PYTHONPATH.<br>Источник: Python <a href="https://docs.python.org/2/library/sys.html#sys.path">2</a> и <a href="https://docs.python.org/3/library/sys.html#sys.path">3</a></p>
</blockquote>
<p>Документация для интерфейса командной строки Python добавляет следующее о запуске сценариев из командной строки. В частности, при запуске команды<code>python script.py</code>, происходит следующее.</p>
<blockquote>
<p>Если имя сценария ссылается непосредственно на файл с расширением <code>py</code>, то каталог, содержащий этот файл, добавляется в начало <code>sys.path</code> и файл выполняется в качестве <strong>основного</strong> модуля.<br>Источник: Python <a href="https://docs.python.org/2/using/cmdline.html">2</a> и <a href="https://docs.python.org/3/using/cmdline.html">3</a></p>
</blockquote>
<p>Давайте рассмотрим порядок, в соответствии с которым  интерпретатор Python ищет модули для импорта:</p>
<ol>
<li>Модули в стандартной библиотеке Python (например, <code>math</code>, <code>os</code>).</li><li>Модули или пакеты в каталоге, заданном в <em>sys.path</em>:<ol>
<li>Если интерпретатор Python запускается в интерактивном режиме:<ul>
<li><code>sys.path[0]</code> - пустая строка &#39; &#39;. Это служит указанием для интерпретатора Python, что в качестве текущего рабочего каталога необходимо использовать каталог из которого был запущен интерпретатор, т. е. результат возвращаемый утилитой <code>pwd</code> в операционных системах Unix.</li></ul>
</li><li>Если мы запускаем сценарий из командной строки с использованием команды вида <code>python script.py</code>:<ul>
<li><code>sys.path[0]</code> - записывается как путь к <code>script.py</code>.</li></ul>
</li></ol>
</li><li>Каталоги в переменной окружения PYTHONPATH</li><li>Значения из переменной <code>sys.path</code>, заданные по умолчанию.</li></ol>
<p>Обратите внимание, что при запуске скрипта Python в <code>sys.path</code> не учитывается, каков ваш текущий «рабочий каталог». Учитывается только о путь к сценарию. Например, если интерпретатор запущен из папки <code>test/</code> и вы запускаете команду <code>python ./packA/subA/subA1.py</code>, то <code>sys.path</code> включает <code>test/packA/subA/</code>, а не <code>test/</code>.</p>
<p>Кроме того, значение <code>sys.path</code> будет использоваться для всех импортированных модулей. Например, предположим, что мы вводим команду <code>python start.py</code>. Пусть <code>start.py</code> импортирует <code>packA.a1</code>, и пусть <code>a1.py</code> выведет содержимое переменной <code>sys.path</code>. Выводимое содержимое переменной <code>sys.path</code> будет включать <code>test/</code> (путь к <code>start.py</code>), а не <code>test/packA/</code> (путь к <code>a1.py</code>). Это означает, что скрипт <code>a1.py</code> может вызывать <code>import other</code>, поскольку файл <code>other.py</code> находится в <code>test/</code>.</p>
<h2 id="-__init__-py-">Все о <code>__init__.py</code></h2>
<p>Файл <code>__init__.py</code> выполняет 2 функции.</p>
<ol>
<li>Преобразование папки со скриптами в импортируемый пакет модулей (до Python 3.3).</li><li>Запуск кода инициализации пакета.</li></ol>
<h3 id="-">Преобразование папки сценариев в импортируемый пакет модулей</h3>
<p>Как уже было сказано выше, любой каталог, содержащий файл с именем <code>__init__.py</code> представляет собой пакет Python. Этот файл так же может быть пустым. Например, при запуске скрипта <code>start.py</code> в Python 2.7 можно импортировать пакет <code>packA</code>, но не <code>packB</code>, так как в каталоге <code>test/packB/</code> нет файла <code>__init__.py</code>.</p>
<p>Это НЕ применимо к Python 3.3 и выше, благодаря принятию неявных пространств имен пакетов. В принципе, Python 3.3+ рассматривает все папки как пакеты, поэтому пустые файлы <code>__init__.py</code> больше не нужны и могут быть опущены.</p>
<p>Например, <code>packB</code> представляет собой пространство имен пакета, поскольку в папке нет файла <code>__init__.py</code>. Если мы запустим интерактивный интерпретатор Python версии 3.6 в каталоге <code>test/</code>, то получим следующий результат:</p>
<pre><code>&gt;&gt;&gt; import packB
&gt;&gt;&gt; packB
&lt;module &#39;packB&#39; (namespace)&gt;
</code></pre><p>Источники:</p>
<ol>
<li><a href="https://stackoverflow.com/q/448271">What is init.py for?</a></li><li><a href="https://www.python.org/dev/peps/pep-0420/">PEP 420: Implicit Namespace Packages.</a></li></ol>
<h3 id="-">Запуск кода инициализации пакета</h3>
<p>В первый раз, когда вы импортируете пакет или один из его модулей, Python будет выполнять файл <code>__init__.py</code> в корневой папке пакета, если этот файл существует. Все объекты и функции, определенные в <code>__init__.py</code>, считаются частью пространства имен пакета.</p>
<p>Рассмотрим следующий пример.</p>
<p>Листинг файла <code>test/packA/a1.py</code>:</p>
<pre><code>def a1_func():
    print(&quot;running a1_func()&quot;)
</code></pre><p>Листинг файла <code>test/packA/__init__.py</code>:</p>
<pre><code>## этот импорт делает a1_func доступной напрямую из packA.a1_func
from packA.a1 import a1_func

def packA_func():
    print(&quot;running packA_func()&quot;)
</code></pre><p>Листинг файла <code>test/start.py</code>:</p>
<pre><code>import packA  # &quot;import packA.a1&quot; будет работать также

packA.packA_func()
packA.a1_func()
packA.a1.a1_func()
</code></pre><p>Команда <code>python start.py</code> выведет следующее:</p>
<pre><code>running packA_func()
running a1_func()    
running a1_func()
</code></pre><p><strong>Примечание</strong>: если в файле <code>a1.py</code> вызывается <code>import a2</code>, и вы запускаете в командной строке команду <code>python a1.py</code>, то <code>test/packA/__ init__.py</code> НЕ будет вызван, хотя на первый взгляд кажется, что <code>a2</code> является частью пакета <code>packA</code>. Так происходит потому, что Python запускает скрипт (в нашем случае <code>a1.py</code>), но содержащая его папка не является пакетом.</p>
<h2 id="-">Использование объектов из импортированного модуля или пакета</h2>
<p>Существует четыре различных вида синтаксиса для записи операторов импорта.</p>
<ol>
<li><code>import &lt;package&gt;</code></li><li><code>import &lt;module&gt;</code></li><li><code>from &lt;package&gt; import &lt;module or subpackage or object&gt;</code></li><li><code>from &lt;module&gt; import &lt;object&gt;</code></li></ol>
<p>Пусть <code>X</code> любое имя после ключевого слова <code>import</code>.</p>
<ul>
<li>если <code>X</code> - это имя модуля или пакета, то для использования объектов, определенных в <code>X</code>, вам нужно написать <code>X.object</code>.</li><li>если <code>X</code> является именем переменной, его можно использовать непосредственно напрямую.</li><li>если <code>X</code> является именем функции, то его можно вызвать с помощью инструкции <code>X()</code>.</li></ul>
<p>Необязательно, но после любого оператора <code>import X</code> может быть добавлена инструкция вида <code>as Y</code>, например, <code>import X as Y</code>. Эта инструкция переименовывает <code>X</code> в <code>Y</code> в пределах файла скрипта. Обратите внимание, что имя <code>X</code> далее не действительно и его использовать не имеет смысла. Например <code>import numpy as np</code>.</p>
<p>Аргументом при ключевом слове <code>import</code> может быть одно имя или список из нескольких имен. Каждое из этих имен может быть также переименовано с помощью ключевого слова <code>as</code>. Например, следующие инструкции импорта в файле в <code>start.py</code> будут работать правильно: <code>import packA as pA</code>, <code>packA.a1, packA.subA.sa1 as sa1</code>.</p>
<p>Рассмотрим следующий пример: в файле <code>start.py</code> необходимо импортировать функцию <code>helloWorld()</code> из файла <code>sa1.py</code>.</p>
<p><strong>Решение №1: </strong></p>
<pre><code>from packA.subA.sa1 import helloWorld
</code></pre><p>затем мы можем вызывать функцию непосредственно по имени: </p>
<pre><code>a = helloWorld()
</code></pre><p><strong>Решение №2: </strong></p>
<pre><code># следующие две строки кода эквивалентны
from packA.subA import sa1
import packA.subA.sa1 as sa1
</code></pre><p>затем мы должны будем использовать в качестве префикса к имени функции имя модуля. </p>
<pre><code>x = sa1.helloWorld()
</code></pre><p>Иногда это решение предпочтительнее Решения №1 для того чтобы сделать явным вызов функции <code>helloWorld</code> из модуля <code>sa1</code>.</p>
<p><strong>Решение №3: </strong></p>
<pre><code>import packA.subA.sa1
</code></pre><p>Далее необходимо использовать полный путь:</p>
<pre><code>x = packA.subA.sa1.helloWorld()
</code></pre><h3 id="-dir-">Использование <code>dir()</code> для проверки содержимого импортированного модуля</h3>
<p>После импорта модуля, используйте функцию <code>dir()</code> для того чтобы получить список доступных имен модуля. Например, предположим, что вы импортируете <code>sa1</code>. Если в <code>sa1.py</code> определена функция <code>helloWorld()</code>, то инструкция <code>dir(sa1)</code> в числе прочих выведет имя <code>helloWorld</code>.</p>
<pre><code>&gt;&gt;&gt; from packA.subA import sa1
&gt;&gt;&gt; dir(sa1)
[&#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;helloWorld&#39;]
</code></pre><h3 id="-">Импорт пакетов</h3>
<p>Импорт пакета концептуально эквивалентен импорту файла <code>__init__.py</code>  из папки пакета в качестве модуля. И действительно это так. Вот как Python рассматривает импортируемый пакет:</p>
<pre><code>&gt;&gt;&gt; import packA
&gt;&gt;&gt; packA
&lt;module &#39;packA&#39; from &#39;packA\__init__.py&#39;&gt;
</code></pre><p>Скриптам, импортирующим пакеты, доступны лишь те объекты, которые были объявлены в файле пакета <code>__init__.py</code>. Например, так как каталог <code>packB</code> не содержит файла <code>__init__.py</code>, то вызов инструкции <code>import packB</code> в Python 3.3+ будет мало полезен, поскольку никакие объекты при импорте пакета <code>packB</code> не будут доступны. Последующий вызов <code>packB.b1</code> завершится неудачей, поскольку объект не будет импортирован.</p>
<h2 id="-">Импорт с использованием абсолютных и относительных путей</h2>
<p><strong>Импорт по абсолютному пути</strong> использует полный путь (начинающийся с корневой папки проекта) до требуемого для импорта модуля .</p>
<p><strong>Импорт по относительному пути</strong> использует относительный путь (начинающийся с пути к текущему модулю) до требуемого для импорта модуля. Существует два вида импорта с использованием относительного пути:</p>
<ul>
<li>явный импорт задается в следующей форме <code>from .&lt;module/package&gt; import X</code>, где <code>&lt;module/package&gt;</code> имеет префикс в виде последовательности имен каталогов, разделенных точками <code>.</code>, которые указывают, на сколько каталогов необходимо переместиться вверх или вниз. При этом одна точка <code>.</code> соответствует текущему каталогу, а две точки <code>..</code> предписывают переместиться на одну папку вверх и т.д.</li><li>неявный импорт записывается так, как будто текущий каталог является частью содержимого переменной <code>sys.path</code>. <strong>Неявный относительный импорт поддерживается только Python 2 и не поддерживается Python 3</strong>.</li></ul>
<p>В документации Python говорится о том, как Python 3+ обрабатывает импорт по относительному пути:</p>
<blockquote>
<p>Единственным верным синтаксисом для импорта по относительному пути является формат <code>from .[module] import name</code>. Все формы инструкции импорта не начинающиеся с точки <code>.</code> интерпретируются как импорт по абсолютному пути.<br>Источник: <a href="https://docs.python.org/3.0/whatsnew/3.0.html">What’s New in Python 3.0</a>.</p>
</blockquote>
<p>Например, предположим, что мы запускаем на исполнение скрипт <code>start.py</code>, который импортирует <code>a1</code>, который, в свою очередь, импортирует <code>other</code>, <code>a2</code> и <code>sa1</code>. Инструкции <code>import</code> в файле <code>a1.py</code> будут выглядеть следующим образом:</p>
<pre><code># импорт по абсолютному пути
import other
import packA.a2
import packA.subA.sa1

# явный импорт по относительному пути
import other
from . import a2
from .subA import sa1

# неявный импорт по относительному пути (не поддерживается в Python 3)
import other
import a2
import subA.sa1
</code></pre><p>Импорт по относительному пути может выполняться только для модулей в пакете; не допускается использовать эту возможность для ссылки на модули, которые находятся в другом каталоге файловой системы. Обратите внимание, что при импорте по относительному пути, точки <code>..</code> помогут перемещаться при поиске файла для импорта только выше каталога (но не включая его), содержащего скрипт, запускаемый из командной строки. Таким образом, <code>from .. import other</code> не будет работать в <code>a1.py</code>. Это приводит к ошибке <strong>ValueError: attempted relative import beyond top-level package</strong> (попытка импорта по относительному пути за пределы пакета верхнего уровня). </p>
<p>В целом импорт по абсолютному пути предпочтительнее чем по относительному. Их использование позволяет избежать путаницы между явным или неявным импортом. Кроме того, любой сценарий, который использует явный импорт по относительному пути, не может быть запущен напрямую:</p>
<blockquote>
<p>Обратите внимание, что импорт по относительному пути основан на имени текущего модуля. Поскольку имя основного модуля всегда «<strong>main</strong>», то модули, предназначенные для использования в качестве основного модуля приложения Python, должны всегда использовать импорт по абсолютному пути.<br>Источники: Python <a href="https://docs.python.org/2/tutorial/modules.html#intra-package-references">2</a> и <a href="https://docs.python.org/3/tutorial/modules.html#intra-package-references">3</a>.</p>
</blockquote>
<p>Источники:</p>
<ul>
<li><a href="https://stackoverflow.com/q/4655526">How to accomplish relative import in python</a></li><li><a href="https://stackoverflow.com/q/12172791">Changes in import statement python3</a></li></ul>
<h2 id="-">Примеры</h2>
<h3 id="-1-sys-path-">Пример 1: содержание <code>sys.path</code> заранее известно</h3>
<p>Если вы запускаете скрипты командой <code>python start.py</code> или <code>python other.py</code>, то вам будет очень просто настроить импорт всех модулей. В этом случае переменная <code>sys.path</code> будет всегда включать директорию <code>test/</code> в списке путей поиска при импорте. Поэтому все операторы импорта могут быть записаны относительно папки <code>test/</code>.</p>
<p><strong>Например</strong>: сценарий в папке <code>test</code> должен импортировать функцию <code>helloWorld()</code> из файла <code>sa1.py</code>.<br><strong>Решение</strong>: <code>from packA.subA.sa1 import helloWorld</code></p>
<h3 id="-2-sys-path-">Пример 2: содержание <code>sys.path</code> может изменяться</h3>
<p>Часто мы хотим гибко использовать сценарии Python независимо от того выполняются ли они в командной строке или импортированы как модуль в другой скрипт. Как будет показано ниже, здесь мы столкнемся с проблемами, а в особенности в коде написанном на Python 3.</p>
<p><strong>Пример</strong>: Предположим, что в сценарии <code>start.py</code> необходимо импортировать <code>a2.py</code>, который в свою очередь должен импортировать <code>sa2.py</code>. Предположим, что <code>start.py</code> всегда  запускается непосредственно напрямую, и никогда не импортируется. Мы также хотим иметь возможность запускать <code>a2.py</code> самостоятельно. Кажется, все достаточно просто. В конце концов, нам нужно всего лишь два оператора импорта: первый в <code>start.py</code> и второй в <code>a2.py</code>.</p>
<p><strong>Проблема</strong>: Это случай, когда <code>sys.path</code> будет изменяться. Когда мы запускаем <code>start.py</code>, переменная <code>sys.path</code> содержит директорию <code>test/</code>. Когда мы запустим файл <code>a2.py</code>, то <code>sys.path</code> будет содержать <code>test/ packA/</code>.</p>
<p>Инструкция <code>import</code> в <code>start.py</code> проста для понимания. Зная заранее, что <code>start.py</code> будет всегда запускаться напрямую и никогда не будет импортирован, мы полагаем, что при его запуске путь <code>test/</code> всегда будет находиться в переменной <code>sys.path</code>. Тогда инструкция для импорта <code>a2.py</code>  будет следующая <code>import packA.a2</code>.</p>
<p>Инструкция <code>import</code> в <code>a2.py</code> более сложна. Когда мы запускаем <code>start.py</code> напрямую, переменная <code>sys.path</code> содержит <code>test/</code>, поэтому в <code>a2.py</code> следует использовать инструкцию <code>from packA.subA import sa2</code>. Однако, если после этого мы будем запускать <code>a2.py</code> напрямую, то переменная <code>sys.path</code> будет содержать путь <code>test/packA/</code>. Теперь инструкция для импорта не будет корректной, поскольку <code>packA</code> не является папкой внутри <code>test/packA/</code>.</p>
<p>Вместо этого мы могли бы попробовать применить инструкцию <code>from subA import sa2</code>. Это решит нашу проблему, если мы запускаем <code>a2.py</code> напрямую. Но теперь у нас возникает проблема, когда мы напрямую запускаем <code>start.py</code>. В Python 3 это не будет выполняться, потому что <code>subA</code> не находится в переменной <code>sys.path</code>. Но будет выполняться без ошибок в Python 2, благодаря поддержке неявного импорта с относительными путями.</p>
<p>Таким образом, по использованию инструкции <code>import</code> в файле <code>a2.py</code> имеем:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Инструкция</strong></th>
<th style="text-align:center"><code>from packA.subA import sa2</code></th>
<th style="text-align:center"><code>from subA import sa2</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>start.py</code></td>
<td style="text-align:center"><strong>Работает</strong></td>
<td style="text-align:center">в Py2 <strong>Работает</strong>,в  Py3 <strong>Не работает</strong> (<code>subA</code> нет в <code>test/</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>a2.py</code></td>
<td style="text-align:center"><strong>Не работает</strong> (packA нет в <code>test/packA/</code>)</td>
<td style="text-align:center"><strong>Работает</strong></td>
</tr>
</tbody>
</table>
<p>Для полноты картины можно попытался использовать импорт по относительному пути: <code>from .subA import sa2</code>. И это будет соответствовать результату выполнения инструкции <code>from packA.subA import sa2</code>.</p>
<p><strong>Решение</strong> (обходной путь решения проблемы): Мне ничего не известно о простом и наглядном способе решения этой проблемы. Вот некоторые обходные пути:</p>
<ol>
<li><p>Используйте импорт по абсолютному пути и <code>test/</code> как корневую директорию (средний столбец в таблице выше). Это гарантирует запуск скрипта <code>start.py</code> напрямую. Чтобы запустить <code>a2.py</code> напрямую, необходимо запустить его как импортированный модуль, а не как скрипт. Для этого надо изменить текущую директорию на <code>test/</code> в консоли, то есть выполнить команду <code>python -m packA.a2</code>.</p>
</li><li><p>Используйте импорт по абсолютному пути и <code>test/</code> как корневую директорию (средний столбец в таблице выше). Это гарантирует, что будет работать напрямую запуск <code>start.py</code>. Чтобы напрямую запустить <code>a2.py</code>, мы можем изменить значение переменной <code>sys.path</code> в <code>a2.py</code>, для того чтобы включить в список путей для импорта путь <code>test/packA/</code>, прежде чем <code>sa2.py</code> будет импортирован.</p>
<pre><code>  import os, sys
  sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

  # now this works, even when a2.py is run directly
  from packA.subA import sa2
</code></pre><p> ПРИМЕЧАНИЕ. Обычно этот метод работает. Однако в некоторых установках Python переменная <em> <em>file_</em></em> может быть некорректной. В этом случае вам нужно будет использовать встроенный в стандартную библиотеку Python пакет <em>inspect</em>. Ознакомьтесь с <a href="https://stackoverflow.com/a/11158224">вопросом на StackOverflow</a> для правильного использования приведенных выше инструкций.</p>
</li><li><p>Используйте только Python 2 если используете неявный импорт по относительному пути (т.е. третий столбец в приведенной выше таблице).</p>
</li><li>Используйте импорт по абсолютному пути, в корне директории <code>test/</code>, и добавьте <code>test/</code> в переменную среды PYTHONPATH.<ul>
<li>это решение не переносимо в другую среду выполнения, поэтому не рекомендуется его применять.</li><li>инструкции по его использованию здесь: <a href="https://stackoverflow.com/q/3402168">Как постоянно добавлять директорию в переменную среды PYTHONPATH</a>/</li></ul>
</li></ol>
<h3 id="-3-sys-path-2-">Пример 3: содержание <code>sys.path</code> может изменяться (вариант 2)</h3>
<p>Более сложная проблема заключается в следующем. Предположим, что <code>a2.py</code> никогда не нужно запускать напрямую, но он импортируется такими файлами, как <code>start.py</code> и <code>a1.py</code>, которые будут запускаться напрямую из консоли.</p>
<p>В этом случае Решение №1 не будет работать. Но другие будут.</p>
<h3 id="-4-">Пример 4: Импорт из родительской директории</h3>
<p>Если мы не собираемся модифицировать переменные PYTHONPATH и <code>sys.path</code> в коде, то в этом случае основным ограничением импорта является следующее: <strong>При непосредственном запуске скрипта через консоль невозможно импортировать что-либо из его родительского каталога.</strong></p>
<p>Например, если вы хотите запустить следующую команду <code>python sa1.py</code>, то невозможно в файле <code>sa1.py</code> что-либо импортировать из <code>a1.py</code>, не прибегая к обходным путям, описанным выше: изменения значений переменных PYTHONPATH или <code>sys.path</code>.</p>
<p>Во-первых, может показаться, что импорт по относительному пути (например, <code>from .. import a1</code>) может обойти это ограничение. Однако скрипт, который выполняется (в данном случае <code>sa1.py</code>) при этом считается «модулем верхнего уровня». Попытка импортировать что-либо из каталога на уровень выше каталога этого скрипта приводит к появлению следующей ошибки: <strong>ValueError: attempted relative import beyond top-level package</strong> (попытка импорта по относительному пути за пределы пакета верхнего уровня).</p>
<p>Можно не писать сценарии, в которых необходимо импортировать что-либо из родительского каталога. В тех случаях когда это все таки необходимо  сделать предпочтительным обходным путем является изменение переменной <code>sys.path</code>.</p>
<h2 id="python-2-vs-python-3">Python 2 VS. Python 3</h2>
<p>Наиболее важные различия между тем, как Python 2 и Python 3 рассматривают инструкции <code>import</code>, были описаны выше. Они снова рассматриваются ниже, наряду с некоторыми другими менее важными отличиями.</p>
<ol>
<li>Python 2 поддерживает неявный импорт по относительному пути, а Python 3 - нет.</li><li>Python 2 требует, чтобы файлы <code>__init__.py</code> находились внутри папки, чтобы папка считалась пакетом и была импортирована. В отличие от него для Python 3.3 и выше, благодаря поддержке неявного пространства имен пакетов, все папки являются пакетами независимо от наличия в них файла <code>__init__.py</code>.</li><li>В Python 2 можно написать <code>from &lt;module&gt; import</code> внутри функции. В Python 3 синтаксис <code>from &lt;module&gt; import</code> разрешен только на уровне модуля, но не внутри функций.</li></ol>
<p>Источники:</p>
<ul>
<li><a href="https://stackoverflow.com/q/12172791">Изменения в инструкциях <em>import</em> в Python 3</a></li><li><a href="https://docs.python.org/2/tutorial/modules.html#intra-package-references">Модули в Python 2 (официальная документация)</a></li><li><a href="https://docs.python.org/3/tutorial/modules.html#intra-package-references">Модули в Python 2 (официальная документация)</a></li><li><a href="https://docs.python.org/3.0/whatsnew/3.0.html">Что нового в Python 3</a></li></ul>
