# Работа с данными в формате JSON в Python

Начиная с момента своего создания [JSON](https://en.wikipedia.org/wiki/JSON) быстро стал стандартом де-факто для обмена данными между приложениями, а также их частями. Скорее всего вы читаете эту статью потому, что вам необходимо куда либо передать данные или возможно вы через API своего приложения собираете информацию, а затем сохраняете её в базу данных. Так или иначе, но вы наконец добрались до JSON и теперь вам необходимо обрабатывать данные в этом формате с помощью Python.   
К счастью это достаточно простая задача, и как в большинстве подобных случаев Python делает ее выполнение пренебрежительно легким.

> Итак, мы собираемся использовать JSON для хранения и обмена данными. JSON - это не что иное, как стандартизованный формат, который сообщество разработчиков использует для передачи данных. Имейте в виду, что JSON - не единственный формат применяемый для решения подобного рода задач, однако только [XML](https://en.wikipedia.org/wiki/XML) и [YAML](http://yaml.org/) вероятно являются единственными, о которых стоит упомянуть в первую очередь.  

## (Очень) Краткое введение в JSON

 **J**ava**S**cript **O**bject **N**otation (JSON) создавался под вдохновением парадигм такого языка программирования как JavaScript и связан с ним своим синтаксисом: описанием объектного литерала. Существует [отличный сайт](https://www.json.org/), который поясняет все это. Тем временем JSON уже давно отделился от языка Javascript и существует как [собственный стандарт](https://tools.ietf.org/html/rfc8259), поэтому  в этой статье мы можем с удовольствием избежать обсуждения особенностей программирования на JavaScript. В конечном итоге сообщество разработчиков в целом приняло JSON, потому что его легко создавать,  а также понимать людям и машинам.

## Внимание, это JSON!

Файлы в формате JSON доступны для чтения и записи всем языкам программирования Cи-стиля, а Python как раз является таковым! Ниже приводится фрагмент кода, содержащий личные данные пользователя в виде объекта закодированного в формате JSON.

```json
{
    "firstName": "Jane",
    "lastName": "Doe",
    "hobbies": ["running", "sky diving", "singing"],
    "age": 35,
    "children": [
        {
            "firstName": "Alice",
            "age": 6
        },
        {
            "firstName": "Bob",
            "age": 8
        }
    ]
} 
```

Как не трудно заметить, JSON поддерживает примитивные типы, такие как строки и числа, а также сложные типы данных: списки и объекты с произвольной вложенностью.

> Код выше похож синтаксисом на словарь из Python. И поэтому является универсальной нотацией для описания объектов.

## Python изначально поддерживает JSON!

Python поставляется с стандартным (встроенным) модулем [json](https://docs.python.org/3/library/json.html) для кодирования и декодирования данных в формате JSON.  
Для этого просто вставьте вверху вашего файла следующие инструкции:

```python
import json
```

### Основные термины

Процесс кодирования JSON называется **сериализацией** (serialization). Этот термин относится к преобразованию данных в линейную последовательность байтов для хранения на диске или передачи по сети. Вы также могли услышать термин «маршалинг» (marshaling), но это тема для еще одной [статьи](https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling).  

Естественно, что **десериализация** (deserialization) является обратным процессом - декодирования данных, которые были сохранены или переданы в формате JSON.

> Так это звучит на техническом языке. Но на самом деле все, все о чем мы говорим - это чтение и запись данных. Думайте об этом так: кодирование предназначено для записи данных на диск (или передачи по сети), а декодирование - для чтения данных в память для последующей обработки.

### Сериализация JSON

Что происходит после того, как компьютер обработает много информации? Конечно же, он должен записать дамп данных (результат) на диск. Соответственно, модуль **json** предоставляет метод `dump()` для записи данных в файл. Существует также метод `dumps()` для записи в строку Python.  
Объекты Python кодируются в формат JSON в соответствии с интуитивно понятным правилом для преобразования,  представленым в таблице ниже.   

| Python           | JSON   |
| ---------------- | ------ |
| dict             | объект |
| list, tuple      | массив |
| str              | строка |
| int, long, float | число  |
| True             | true   |
| False            | false  |
| None             | null   |

### Пример простой процедуры сериализации данных

Представьте, что вы работаете с объектом Python в памяти, который выглядит следующим образом:

```python
data = {
    "president": {
        "name": "Zaphod Beeblebrox",
        "species": "Betelgeusian"
    }
}  
```

Важно сохранить эту информацию на диске, поэтому наша задача записать ее в файл.   
Используя диспетчер контекстов Python, вы можете создать файл с именем `data_file.json` и открыть его в режиме записи (Названия файлов JSON заканчиваются расширением `.json`).  

```python
with open("data_file.json", "w") as write_file:
    json.dump(data, write_file)  
```

Обратите внимание, что функция `dump()` принимает два позиционных аргумента: (1) объект данных, подлежащий сериализации, и (2) файл-подобный объект, в который будут записываться данные.   
Или, если вы хотите далее в своем приложении продолжать использовать сериализованные данные в формате JSON, вы можете записать их в нативный объект Python типа *str* (строка).  

```python
json_string = json.dumps(data)  
```

Обратите внимание, что второй аргумент, содержащий файл-подобный объект отсутствует, так как на самом деле данные не записываются на диск. Кроме этой особенности, функция `dumps()` аналогична `dump()`.

### Некоторые полезные именованные аргументы

Помните, что JSON должен быть легко читаемым для людей, но этого недостаточно, если все наши данные будут упакованы в одну строку без отступов и разделения по отдельным строкам. Кроме того, у вас вероятно имеется свой стиль форматирования и вам проще читать код, отформатированный как вам нравится.

> **ПРИМЕЧАНИЕ.** Оба метода `dump()` и `dumps()` используют одни и те же именованные аргументы.

Первая опция, которую большинство людей хочет изменить - это количество пробельных символов отступе. Вы можете использовать именованный аргумент `indent`, чтобы указать размер отступа для вложенных структур. Почувствуйте разницу в форматировании кода, для чего используя данные, которые мы определили выше в переменной `data`, выполните следующие команды в консоли:  

```shell
>>> json.dumps(data)
>>> json.dumps(data, indent=4)
```

Другая опция для форматирования - это именованный аргумент `separators`. По умолчанию в качестве разделителей используется строка, состоящая из двух символов (", ", ": "), но обычной альтернативой для придания файлу JSON более компактного вида является разделители в виде строк вида: "," и ":". Выполнив в качестве примера в консоли команды, приведенные выше, и задав новое значение аргумента `separators`,  можно заметить, как вид разделителей изменит форматирование данных.   

Есть и другие именованные аргументы, например `sort_keys`, но далее здесь мы не будем их рассматривать. Полный список именованных аргументов и их значений можно найти в [документации](https://docs.python.org/3/library/json.html#basic-usage).

### Десериализация JSON

В модуле **json** вы найдете функции `load()` и `loads()` для преобразования кодированных в формате JSON данных в объекты Python.  
Подобно процедуре *сериализации*, существует простая таблица преобразования типов для *десериализации*, хотя вероятно вы уже догадались, как она будет выглядеть:  

JSON | Python
------------- | -------------
объект  | dict
массив | list
строка | str
число (int) | int
число (float) | float
true | True
false | False
null | None  

Технически это преобразование не является в точности обратным к таблице *сериализации*, приведенной выше. Это означает, что если вы кодируете объект в данные в формате JSON, а затем  позже декодируете его, вы можете получить обратно не тот же самый объект, каким он был первоначально.  
Простым примером этого будет кодирование данных с типом кортеж (*tuple*) и получение после декодирования данных с типом списк (*list*) :  

```bash
>>> blackjack_hand = (8, "Q")
>>> encoded_hand = json.dumps(blackjack_hand)
>>> decoded_hand = json.loads(encoded_hand)

>>> blackjack_hand == decoded_hand
False
>>> type(blackjack_hand)
<class 'tuple'>
>>> type(decoded_hand)
<class 'list'>
>>> blackjack_hand == tuple(decoded_hand)
True
```


### Простой пример десериализации данных  
На этот раз представьте, что у вас есть данные, хранящиеся на диске, которые вы хотите обрабатывать в памяти. Как в задаче выше вы также можете использовать диспетчер контекста, но на этот раз для того, чтобы открыть существующий файл `data_file.json` в режиме чтения.  

```python
with open("data_file.json", "r") as read_file:
    data = json.load(read_file)
```

Здесь все довольно просто, но имейте в виду, что результат выполнения этого кода будет возвращать результат декодирования JSON, в соответствии с представленной выше таблицей  преобразования типов данных. Об этом очень важно помнить если вы загружаете из файла данные, состав которых вам заранее неизвестен. В большинстве случаев корневой объект будет представлять собой словарь (*dict*) или список (*list*).  
Если вы получаете данные в формате JSON из другой программы или ваш код Python должен обработать строку данных, форматированных в JSON, вы можете легко десериализовать их с помощью функции `load()`. В коде приведенном ниже, данные просто загружаются из строки:  

```python
json_string = """
{
    "researcher": {
        "name": "Ford Prefect",
        "species": "Betelgeusian",
        "relatives": [
            {
                "name": "Zaphod Beeblebrox",
                "species": "Betelgeusian"
            }
        ]
    }
}
"""
data = json.loads(json_string)
```

### Пример (как бы) из реальной жизни ###

Для нашего примера мы будем использовать [JSONPlaceholder](https://jsonplaceholder.typicode.com/), отличный источник поддельных данных в формате JSON для отладки ваших приложений. Для этого сначала создайте файл сценария с именем `scratch.py` или любым другим именем.  
Вам нужно будет сформировать запрос `request` к служебному API [JSONPlaceholder](https://jsonplaceholder.typicode.com/), для этого проще использовать модуль [requests](http://docs.python-requests.org/en/master/), который проделает всю тяжелую работу за вас. Для этого добавьте эти объявления импорта в начало файла:  

```python
import json
import requests  
```

Теперь мы будем работать со списком [TODO](https://jsonplaceholder.typicode.com/todos), обращаясь к интерфейсу API [JSONPlaceholder](https://jsonplaceholder.typicode.com/) относительно входной точки `/todos`. Если вы не знакомы с модулем [requests](http://docs.python-requests.org/en/master/), то вы можете использовать удобный метод `json()`, который выполнит эту работу. Но мы в нашем примере будем использовать модуль [json](https://docs.python.org/3/library/json.html) для десериализации атрибута `text` объекта ответа `response`, полученного с помощью модуля [requests](http://docs.python-requests.org/en/master/). Код нашего примера будет выглядеть следующим образом:  

```python
response = requests.get("https://jsonplaceholder.typicode.com/todos")
todos = json.loads(response.text)  
```

Запустите файл в интерактивном режиме с помощью командной строки и протестируйте его работу самостоятельно.

 Когда вы сделаете это, то проверьте тип объекта `todos`. А затем проверьте элементы списка.  

```shell
>>> todos == response.json()
True
>>> type(todos)
<class 'list'>
>>> todos[:10]
...  
```

Вы сможете посмотреть вид структуры входных данных, посетив входную точку с помощью браузера, перейдя по следующей ссылке [TODO](https://jsonplaceholder.typicode.com/todos):  

```json
{
    "userId": 1,
    "id": 1,
    "title": "delectus aut autem",
    "completed": false
}  
```

[JSONPlaceholder](https://jsonplaceholder.typicode.com/) генерирует набор следующих данных: нескольких пользователей, каждый из которых имеет уникальный идентификатор `userId`, а также имеет поле `completed` (состояние задачи) с типом `Boolean`. Как определить какие пользователи выполнили наибольшее количество задач? 

```python
# таблица userId спользователей полности выполнивших все задачи из TODO
todos_by_user = {}

# Подсчет количества задач из списка TODO выполненных каждым пользователем
for todo in todos:
    if todo["completed"]:
        try:
            # Суммируем (с помощью оператора инкремента) количество выполненных пользователем задач.
            todos_by_user[todo["userId"]] += 1
        except KeyError:
            # Этот пользователь ничего не сделал. Зададим количество задач равным 1.
            todos_by_user[todo["userId"]] = 1

# Создадим сортированный список пар (userId, num_complete)
top_users = sorted(todos_by_user.items(), 
                   key=lambda x: x[1], reverse=True)

# Зададим максимальное количество выполненных задач TODO в списке
max_complete = top_users[0][1]

# Создадим список list всех пользователей, которые имеют максимальное количество выполненных задач из TODO 
users = []
for user, num_complete in top_users:
    if num_complete < max_complete:
        break
    users.append(str(user))

max_users = " and ".join(users)  
```

Таким образом теперь мы можем манипулировать считанными из файла JSON данными как обыкновенным объектом Python.
Когда мы запустим представленный выше код, то получим следующий результат:  

```shell
>>> s = "s" if len(users) > 1 else ""
>>> print(f"user{s} {max_users} completed {max_complete} TODOs")
users 5 and 10 completed 12 TODOs
# пользователи 5 и 10 выполнили 12 задач из TODO  
```

Для окончательного выполнения нашего задания создадим файл JSON, который будет содержать заполненные TODO для каждого из пользователей, которые завершили максимальное количество задач из списка TODO.   
Все, что теперь вам нужно сделать, это отфильтровать задачи `todos` и записать полученный список в файл. Назовем выходной файл `filter_data_file.json`. Существует несколько способов, которыми можно это сделать. Ниже приведен один из них:  

```python
# Определим функцию для фильтрации пользователей,
# выполнивших максимальное количество заданий из TODO
def keep(todo):
    is_complete = todo["completed"]
    has_max_count = todo["userId"] in users
    return is_complete and has_max_count

# Запишем отфильтрованные данные в файл
with open("filtered_data_file.json", "w") as data_file:
    filtered_todos = list(filter(keep, todos))
    json.dump(filtered_todos, data_file, indent=2)
```

Отлично, мы сохранили нужные нам данные в файл, отфильтровав все лишнее. Запустите сценарий еще раз и проверьте файл `filter_data_file.json`, чтобы убедиться, что все работает как нам нужно. Он будет создан в том же каталоге, что и файл `scratch.py`, который мы запускали с помощью консоли.  


## Кодирование и декодирование пользовательских объектов Python ##  

Что происходит, когда мы пытаемся сериализовать класс `Elf` из приложения `Dungeons & Dragons`, над которым, например, вы работаете?  

```python
class Elf:
    def __init__(self, level, ability_scores=None):
        self.level = level
        self.ability_scores = {
            "str": 11, "dex": 12, "con": 10,
            "int": 16, "wis": 14, "cha": 13
        } if ability_scores is None else ability_scores
        self.hp = 10 + self.ability_scores["con"]
```

Не удивительно, что Python пожалуется, что `Elf` не может быть сериализован (*not serializable*):

```bash
>>> elf = Elf(level=4)
>>> json.dumps(elf)
TypeError: Object of type 'Elf' is not JSON serializable
```

Хотя модуль **json** может обрабатывать большинство встроенных типов данных Python, по умолчанию он не понимает, как  кодировать сложные пользовательские типы данных. Со стороны это похоже на попытку поместить квадратный штифт в круглое отверстие.  

### Упрощение структур данных ###

Как работать со сложными структурами данных? Вы можете попытаться кодировать и декодировать JSON вручную контролируя весь процесс, но есть более изящное решение, которое сэкономит ваше время. Вместо того, чтобы попытаться напрямую перейти от пользовательского типа данных к формату JSON с неизвестным результатом, вы можете сделать это через промежуточный шаг.

Все, что вам нужно сделать, это представить ваши данные с точки зрения встроенных в Python (нативных) типов данных, которые модуль **json** отлично понимает. По сути, вы должны перевести сложный объект в более простое представление, которое модуль **json** затем трансформирует в JSON. Это похоже на транзитивное свойство отношений элементов в математике: если **A = B** и **B = C**, то **A = C**. 

Чтобы опробовать это, нам понадобится любой сложный объект для кодирования. Для примера вы можете использовать любой пользовательский класс, который вам нравится. Но мы используем для этого встроенный в Python тип [complex](https://www.mathsisfun.com/numbers/complex-numbers.html), который используется для представления комплексных чисел. И по умолчанию он не сериализуем. 

```shell
>>> z = 3 + 8j
>>> type(z)
<class 'complex'>
>>> json.dumps(z)
TypeError: Object of type 'complex' is not JSON serializable
```


Теперь необходимо задать себе очень важный  вопрос. **Каков минимальный объем информации, необходим для воссоздания объекта?** В случае комплексных чисел вам нужно знать значения реальных и мнимых частей числа, которые вы можете получить как атрибуты объекта с типом [complex](https://www.mathsisfun.com/numbers/complex-numbers.html):  

```shell
>>> z.real
3.0
>>> z.imag
8.0
```

После передачи чисел, полученных в качестве результата в конструктор  `complex()`  (типа данных комплексное число) оператор сравнения `__eq__` вернул значение `True`:  

```shell
>>> complex(3, 8) == z
True
```

Разбиение данных пользовательских типов до составляющих их элементов с простыми базовыми типами, имеет решающее значение для успешного результата работы процессов сериализации и десериализации.

### Кодирование пользовательских типов данных ###
Для того чтобы преобразовать объект пользовательского типа в формат JSON, вам необходимо предусмотреть функцию кодирования для передачи ее через именованный параметр `default` функции `dump()`. Модуль **json** будет вызывать эту функцию для любых объектов, которые не могут быть сериализованы способом по умолчанию. Вот, например, простая функция декодирования, которую вы можете использовать на практике:  

```python
def encode_complex(z):
    if isinstance(z, complex):
        return (z.real, z.imag)
    else:
        type_name = z.__class__.__name__
        raise TypeError(f"Object of type '{type_name}' is not JSON serializable")  
```

Обратите внимание, на то что вы должны генерировать исключение **TypeError**, если не получите объект ожидаемого типа. Теперь вы можете попробовать кодировать сложные пользовательские объекты:

```shell
>>> json.dumps(9 + 5j, default=encode_complex)
'[9.0, 5.0]'
>>> json.dumps(elf, default=encode_complex)
TypeError: Object of type 'Elf' is not JSON serializable
```

> **Почему мы кодировали комплексное число как кортеж (*tuple*)?** Хороший вопрос. Это, безусловно, не единственный и не лучший выбор. На самом деле, это не очень хорошее представление данных, в особенности если бы вы захотели позже декодировать, полученный результат. И вы вскоре убедитесь в этом.

Другой общий подход заключается в применении подкласса стандартного класса `JSONEncoder` и переопределении его метода `default()`:  

```python
class ComplexEncoder(json.JSONEncoder):
    def default(self, z):
        if isinstance(z, complex):
            return (z.real, z.imag)
        else:
            super().default(self, z)
```

Вместо того, чтобы генерировать исключения типа **TypeError**, вы просто можете позволить базовому классу обработать его. Вы можете использовать это либо непосредственно в методе `dumps()` через параметр `cls`, либо путем создания экземпляра `encoder` (кодера) и вызова его метода `encode()`:  

```shell
>>> json.dumps(2 + 5j, cls=ComplexEncoder)
'[2.0, 5.0]'

>>> encoder = ComplexEncoder()
>>> encoder.encode(3 + 6j)
'[3.0, 6.0]'
```

### Декодирование пользовательских типов данных ###

Хотя значения реальных и мнимых частей необходимы для воссоздания объекта типа `complex` (комплексное число), но на практике этого может оказаться недостаточно . Например, попытаемся кодировать в формате JSON комплексное число с помощью класса `ComplexEncoder` , а затем декодировать результат в объект Python:  

```shell
>>> complex_json = json.dumps(4 + 17j, cls=ComplexEncoder)
>>> json.loads(complex_json)
[4.0, 17.0]
```

Из этого кода видно, что если вы захотите получить объект с типом `complex`, то полученный список значений (*list*) необходимо передать в соответствующий конструктор `complex()`. 

Таким образом для достоверного декодирования JSON нам необходимо заранее знать тип данных объекта, который должен быть получен.           

В рассмотренном нами случае отсутствуют метаданные или информация о типе декодируемых данных.  
Теперь еще раз зададим себе следующий вопрос: **Каков минимальный объем информации, который необходим и достаточен для восстановления этого объекта?**

Модуль **json** ожидает, что все пользовательские типы данных будут отображаться как объекты в стандарте JSON. Для разнообразия вы можете создать файл  JSON на этот раз с именем `complex_data.json` и добавить туда следующий объект, описывающий комплексное число:

```python
{
    "__complex__": true,
    "real": 42,
    "imag": 36
}  
```

Ключ `__complex__`- это метаданные, о которых мы говорили выше. На самом деле не важно с каким значением он ассоциирован. Чтобы этот маленький *хак* работал, все, что вам нужно это проверить существует ли этот ключ:  

```python
def decode_complex(dct):
    if "__complex__" in dct:
        return complex(dct["real"], dct["imag"])
    return dct
```

Если ключа `__complex__` нет в словаре, вы можете просто вернуть объект или осуществить преобразование декодером по умолчанию.  
Каждый раз, когда метод `loads()` пытается проанализировать объект `object`, вам предоставляется возможность изменить его поведение перед тем, как декодер по умолчанию начнет работать с данными. Вы можете сделать это, передав вашу функцию декодирования через именованный параметр `object_hook`.  
Запустим на выполнение следующий код:  

```shell
>>> with open("complex_data.json") as complex_data:
...     data = complex_data.read()
...     z = json.loads(data, object_hook=decode_complex)
... 
>>> type(z)
<class 'complex'>
```

Хотя параметр `object_hook` может показаться аналогичным параметру `default` функции`dump()`, однако это не так.
Этот код работает не только с одним объектом. Попробуйте поместить список (*list*) объектов наших комплексных чисел в `complex_data.json` и снова запустить скрипт:  

```json
[
  {
    "__complex__":true,
    "real":42,
    "imag":36
  },
  {
    "__complex__":true,
    "real":64,
    "imag":11
  }
]
```

Если наш код правильный, то вы получите список объектов типа `complex`:

```shell
>>> with open("complex_data.json") as complex_data:
...     data = complex_data.read()
...     numbers = json.loads(data, object_hook=decode_complex)
... 
>>> numbers
[(42+36j), (64+11j)]  
```

Вы также можете попробовать использовать подкласс класса `JSONDecoder` и переопределить его метод `object_hook`, но лучше всего придерживаться самого простого решения.

## Все готово
Поздравляю теперь вы можете использовать всю мощь формата JSON для реализации ваших приложений на языке Python.  

Хотя примеры с которыми мы работали здесь, безусловно, чрезмерно упрощены, но иллюстрируют основы рабочего процесса. Вы также можете применить их к решению следующих задач:  

1. Импорт модуля **json**.  
2. Чтение данных с использованием функций `load()` или `loads()`.  
3. Обработка данных.  
4. Запись измененных данные с помощью функций `dump()` или `dumps()`.

То, что вы будете делать с данными после их загрузки в память, будет зависеть от конкретного варианта использования. Как правило, вашей целью будет получение данных из источника, извлечение и обработка полезной информации и передача информации далее или запись ее.  

Изучение стандартного модуля **json** делает проще изучение других модулей Python, использующихся для сериализации данных: [pickle](https://docs.python.org/3/library/pickle.html) и [marshal](https://docs.python.org/3/library/marshal.html).

Удачи вам в изучении Python!



