# Работа с данными в формате JSON в Python

Начиная с момента своего создания [JSON](https://en.wikipedia.org/wiki/JSON) быстро стал стандартом де-факто для обмена данными между приложениями, а также их частями. Скорее всего вы читаете эту статью потому, что вам необходимо куда либо передать данные или возможно вы через API своего приложения собираете информацию, а затем сохраняете её в базу данных. Так или иначе, но вы наконец добрались до JSON и теперь вам необходимо обработать данные в этом формате с помощью Python.   
К счастью это достаточно легкая задача, и как в большинстве подобных случаев Python делает ее выполнение простым.

> Итак, мы собираемся использовать JSON для хранения и обмена данными. JSON - это не что иное, как стандартизованный формат, который сообщество разработчиков использует для передачи и хранения данных. Имейте в виду, что JSON - не единственный формат применяемый для решения подобного рода задач, однако только [XML](https://en.wikipedia.org/wiki/XML) и [YAML](http://yaml.org/) вероятно являются единственными, о которых стоит упомянуть в первую очередь.  

## (Очень) Краткое введение в JSON

 **J**ava**S**cript **O**bject **N**otation (JSON) создавался под вдохновением парадигм языка JavaScript и связан с ним синтаксисом описания объектного литерала. Существует [отличный сайт](https://www.json.org/), который введет вас в курс дела. Тем временем JSON уже давно отделился от языка Javascript и существует как [собственный стандарт](https://tools.ietf.org/html/rfc8259), поэтому  в этой статье мы можем с удовольствием избежать обсуждения особенностей программирования на JavaScript. В конечном итоге сообщество разработчиков в целом приняло JSON, так как его легко создавать, а также понимать как людям, так и машинам.

## Внимание, это JSON!

Файлы в формате JSON доступны для чтения и записи всем языкам программирования Cи-стиля, а Python как раз является таковым! Ниже приводится фрагмент кода, содержащий личные данные пользователя в виде объекта закодированного в формате JSON.

```json
{
    "firstName": "Jane",
    "lastName": "Doe",
    "hobbies": ["running", "sky diving", "singing"],
    "age": 35,
    "children": [
        {
            "firstName": "Alice",
            "age": 6
        },
        {
            "firstName": "Bob",
            "age": 8
        }
    ]
} 
```

Как не трудно заметить, JSON поддерживает примитивные типы данных, такие как строки и числа, а также сложные: списки и объекты с произвольной вложенностью.

> Синтаксис представленного выше кода схож синтаксисом словаря Python. И поэтому является универсальной нотацией для описания объектов.

## Python изначально поддерживает JSON!

Python поставляется со стандартным (встроенным) модулем [**json**](https://docs.python.org/3/library/json.html) для кодирования и декодирования данных в формате JSON.  
Для этого просто вставьте в начале вашего файла следующие инструкции:

```python
import json
```

### Основные термины

Процесс кодирования JSON называется **сериализацией** (serialization). Этот термин относится к преобразованию данных в линейную последовательность байтов для хранения на диске или передачи по сети. Интересуясь материалами по этой тематике, вы также могли слышать термин «маршалинг» (marshaling), но это тема для еще одной отдельной [статьи](https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling).  

Соответственно, **десериализация** (deserialization) является обратным процессом - декодирования данных в формате JSON.

> Так это звучит на техническом языке. Но на самом деле все о чем мы сейчас говорим - это чтение и запись данных. Думайте об этом так: кодирование предназначено для записи данных на диск (или передачи по сети), а декодирование - для чтения данных в память для последующей обработки.

### Сериализация JSON

Что происходит после того, как компьютер обработает много информации? Конечно же, он должен записать дамп данных (результат) на диск. Соответственно, модуль **json** предоставляет метод `dump()` для записи данных в файл. Существует также метод `dumps()` для записи в строку Python.  
Объекты Python кодируются в формат JSON в соответствии с интуитивно понятным правилом для преобразования,  представленным в виде таблице ниже.   

| Python           | JSON   |
| ---------------- | ------ |
| dict             | объект |
| list, tuple      | массив |
| str              | строка |
| int, long, float | число  |
| True             | true   |
| False            | false  |
| None             | null   |

### Пример простой процедуры сериализации данных

Представьте, что вы работаете с объектом Python в памяти, который выглядит следующим образом:

```python
data = {
    "president": {
        "name": "Zaphod Beeblebrox",
        "species": "Betelgeusian"
    }
}  
```

Важно сохранить эту информацию на диске и наша задача записать ее в файл.   
Используя диспетчер контекстов Python, вы можете создать файл с именем `data_file.json` и открыть его в режиме записи (названия файлов JSON заканчиваются расширением .json).   

```python
with open("data_file.json", "w") as write_file:
    json.dump(data, write_file)  
```

Обратите внимание, что метод`dump()` принимает два позиционных аргумента: (1) объект данных, подлежащий сериализации, и (2) файлоподобный объект, в который данные будут записаны.   
Если же вы хотите в своем приложении далее продолжать использовать сериализованные данные, вы можете записать их в объект встроенного типа Python - `str` (строка).  

```python
json_string = json.dumps(data)  
```

Обратите внимание, что второй аргумент, который содержит ссылку на файлоподобный объект для записи, отсутствует, так как на самом деле данные не записываются на диск, а сохраняются в переменной `json_string`. Кроме этой особенности, во всем остальном метод`dumps()` аналогичен `dump()`.

### Некоторые полезные именованные аргументы

Напомним, что JSON должен быть легко читаемым для людей. Но что если наши данные будут упакованы в одну строку без отступов и разделения по отдельным строкам. Кроме всего этого, у вас вероятно имеется свой стиль форматирования (styleguide) или вам проще читать код, отформатированный по вашим правилам.

> **ПРИМЕЧАНИЕ.** Оба метода `dump()` и `dumps()` используют одни и те же именованные аргументы.

Первая опция, которую большинство людей хочет изменить - это количество пробельных символов отступе. Вы можете использовать именованный аргумент `indent`, чтобы указать размер отступа для вложенных структур. Используя данные, которые мы определили выше в переменной `data`, выполните следующие команды в консоли, а затем сравните результаты выполнения обеих инструкций:  

```shell
>>> json.dumps(data)
>>> json.dumps(data, indent=4)
```

Другая опция для форматирования - использование именованного аргумента `separators`. По умолчанию в качестве разделителей в файлах JSON используется строка, состоящая из двух символов: ", " и ": " (последний символ *пробел*). Но альтернативным решением для придания файлу более компактного вида является использование разделителей в виде строк вида: "," и ":" (без *пробела* в конце). Выполнив в качестве примера в консоли команды, приведенные выше, и задав новое значение аргумента `separators`,  можно заметить, как вид разделителей изменит форматирование ваших данных.  

### Десериализация JSON

В модуле **json** определены методы `load()` и `loads()`, предназначенные для преобразования кодированных в формате JSON данных в объекты Python.  
Подобно процедуре *сериализации*, существует таблица преобразования типов, определяющая правила для *десериализации* данных. Хотя вероятно вы уже догадались, как она будет выглядеть:    

JSON | Python
------------- | -------------
объект  | dict
массив | list
строка | str
число (int) | int
число (float) | float
true | True
false | False
null | None  

Технически это преобразование не является в точности обратным к таблице для *сериализации* данных, рассмотренной нами выше. Это означает, что если вы кодируете объект в данные в формате JSON, а затем декодируете его обратно, то вы можете получить обратно уже не тот самый объект, каким он был изначально.  
Простым иллюстрирующим этот факт примером будет кодирование данных с типом кортеж (*tuple*) и получение после обратного декодирования данных уже с типом список (*list*) :  

```bash
>>> blackjack_hand = (8, "Q")
>>> encoded_hand = json.dumps(blackjack_hand)
>>> decoded_hand = json.loads(encoded_hand)

>>> blackjack_hand == decoded_hand
False
>>> type(blackjack_hand)
<class 'tuple'>
>>> type(decoded_hand)
<class 'list'>
>>> blackjack_hand == tuple(decoded_hand)
True
```


### Простой пример десериализации данных  
На этот раз представьте, что у вас есть данные, хранящиеся на диске, которые вы хотите обрабатывать в памяти. Как в задаче выше вы также можете использовать диспетчер контекста, но на этот раз для того, чтобы открыть существующий файл `data_file.json` в режиме чтения:  

```python
with open("data_file.json", "r") as read_file:
    data = json.load(read_file)
```

Здесь все довольно просто, но имейте в виду, что результат выполнения этого кода будет возвращать результат декодирования JSON, в соответствии с представленной выше таблицей  преобразования типов данных. Об этом очень важно помнить если вы загружаете из файла данные, состав которых вам заранее неизвестен.     

 В большинстве случаев корневой объект будет представлять собой словарь (*dict*) или список (*list*).  
Допустим, что вы получаете данные в формате JSON из другой программы или ваш код Python должен обработать строку данных (c типом `str`), отформатированную в формате JSON. В этом случае вы можете легко десериализовать их с помощью метода`loads()`. В приведенном ниже коде, данные просто загружаются из строки:  

```python
json_string = """
{
    "researcher": {
        "name": "Ford Prefect",
        "species": "Betelgeusian",
        "relatives": [
            {
                "name": "Zaphod Beeblebrox",
                "species": "Betelgeusian"
            }
        ]
    }
}
"""
data = json.loads(json_string)
```

### Пример (как бы) из реальной жизни ###

Для нашего примера мы будем использовать online-сервис [JSONPlaceholder](https://jsonplaceholder.typicode.com/). Он представляет собой удобный в использовании удаленный источник данных в формате JSON, получаемых по сети, которые могут использоваться вами для отладки приложений. Для этого сначала создадим файл сценария с именем `scratch.py` или под любым другим именем.  
Вам необходимо будет сформировать запрос `request` к служебному API [JSONPlaceholder](https://jsonplaceholder.typicode.com/), для этого можно использовать модуль [requests](http://docs.python-requests.org/en/master/). Для этого просто добавьте эти инструкции импорта в начало вашего файла:  

```python
import json
import requests  
```

Теперь мы будем работать со списком [TODO](https://jsonplaceholder.typicode.com/todos), обращаясь через интерфейс API [JSONPlaceholder](https://jsonplaceholder.typicode.com/) относительно входной точки `/todos`. Если вы не знакомы с модулем [requests](http://docs.python-requests.org/en/master/), то вы можете использовать другой удобный метод `json()`, который выполнит эту же задачу. В нашем же примере мы будем использовать модуль [json](https://docs.python.org/3/library/json.html) для десериализации атрибута `text` объекта ответа `response`, полученного с помощью модуля [requests](http://docs.python-requests.org/en/master/). Код нашего примера будет выглядеть следующим образом:  

```python
response = requests.get("https://jsonplaceholder.typicode.com/todos")
todos = json.loads(response.text)  
```

Запустите файл в интерактивном режиме с помощью командной строки.

Сделав это, проверьте тип объекта `todos`, а также содержимое элементов этого списка значений.  

```shell
>>> todos == response.json()
True
>>> type(todos)
<class 'list'>
>>> todos[:10]
...  
```

Вы можете посмотреть содержимое входных данных с помощью браузера, перейдя во входную точку сервиса по следующей ссылке - [TODO](https://jsonplaceholder.typicode.com/todos):  

```json
{
    "userId": 1,
    "id": 1,
    "title": "delectus aut autem",
    "completed": false
}  
```

[JSONPlaceholder](https://jsonplaceholder.typicode.com/) генерирует набор следующих данных: список пользователей, каждый из которых имеет уникальный идентификатор `userId`, а также поле `completed` (состояние задачи) с типом `Boolean`. Как определить какие пользователи выполнили наибольшее количество задач? Представленный ниже код выполняет эту задачу.

```python
# таблица userId спользователей полностью выполнивших все задачи из TODO
todos_by_user = {}

# Подсчет количества задач из списка TODO выполненных каждым пользователем
for todo in todos:
    if todo["completed"]:
        try:
            # Суммируем количество выполненных пользователем задач.
            todos_by_user[todo["userId"]] += 1
        except KeyError:
            # Этот пользователь ничего не сделал. Зададим количество выполненных задач равным 1.
            todos_by_user[todo["userId"]] = 1

# Создадим сортированный список пар значений (userId, num_complete)
top_users = sorted(todos_by_user.items(), 
                   key=lambda x: x[1], reverse=True)

# Зададим максимальное количество выполненных задач TODO в списке
max_complete = top_users[0][1]

# Создадим список list всех пользователей, которые имеют максимальное количество выполненных задач из списка TODO 
users = []
for user, num_complete in top_users:
    if num_complete < max_complete:
        break
    users.append(str(user))

max_users = " and ".join(users)  
```

Таким образом теперь мы можем манипулировать данными, прочитанными из файла JSON, как обыкновенным объектом Python.
Если мы запустим это код в консоли, то получим следующий результат:  

```shell
>>> s = "s" if len(users) > 1 else ""
>>> print(f"user{s} {max_users} completed {max_complete} TODOs")
users 5 and 10 completed 12 TODOs
# пользователи 5 и 10 выполнили 12 задач из TODO  
```

Для окончательного выполнения нашего задания создадим файл JSON, который будет содержать заполненные TODO для каждого из пользователей, которые завершили максимальное количество задач из списка TODO.   
Все, что теперь вам нужно сделать, это отфильтровать задачи `todos` и записать полученный список в файл. Назовем выходной файл `filter_data_file.json`. Существует несколько способов, которыми можно это сделать. Ниже приведен один из них:  

```python
# Определим функцию для фильтрации пользователей,
# выполнивших максимальное количество заданий из TODO
def keep(todo):
    is_complete = todo["completed"]
    has_max_count = todo["userId"] in users
    return is_complete and has_max_count

# Запишем отфильтрованные данные в файл
with open("filtered_data_file.json", "w") as data_file:
    filtered_todos = list(filter(keep, todos))
    json.dump(filtered_todos, data_file, indent=2)
```

Отлично, мы сохранили нужные нам данные в файл, отфильтровав все лишнее. Запустите сценарий еще раз и проверьте файл `filter_data_file.json`, чтобы убедиться, что все работает как нам нужно. Он будет создан в том же каталоге, что и файл `scratch.py`.  


## Кодирование и декодирование пользовательских объектов Python ##  

Рассмотрим следующий пример и ответим на вопрос. Что произойдёт когда мы попытаемся сериализовать класс `Elf` из приложения `Dungeons & Dragons` фрагмент кода которого представлен ниже?  

```python
class Elf:
    def __init__(self, level, ability_scores=None):
        self.level = level
        self.ability_scores = {
            "str": 11, "dex": 12, "con": 10,
            "int": 16, "wis": 14, "cha": 13
        } if ability_scores is None else ability_scores
        self.hp = 10 + self.ability_scores["con"]
```

Не удивительно, но Python пожалуется, что `Elf` не может быть сериализован (*not serializable*):

```bash
>>> elf = Elf(level=4)
>>> json.dumps(elf)
TypeError: Object of type 'Elf' is not JSON serializable
```

Хотя модуль **json** может обрабатывать большинство встроенных типов данных Python, но по умолчанию он не понимает, как  кодировать сложные пользовательские типы данных. Со стороны наш код похож на попытку поместить квадратный штифт в круглое отверстие. Как решать подобные задачи рассмотрим ниже.

### Упрощение структур данных ###

Как работать со сложными структурами данных? Вы можете попытаться кодировать и декодировать JSON вручную контролируя весь процесс, но есть более изящное решение, которое сэкономит ваше время. Вместо того, чтобы попытаться напрямую перейти от пользовательского типа данных к формату JSON с неизвестным результатом, вы можете сделать это через следующий промежуточный шаг.

Все, что вам нужно сделать, это представить ваши данные с точки зрения встроенных в Python (нативных) типов данных, которые модуль **json** отлично понимает. По сути, вы должны перевести сложный объект в более простое представление, которое модуль **json** затем трансформирует в JSON. Это похоже на транзитивное свойство отношений элементов в математике: если **A = B** и **B = C**, то **A = C**. 

Чтобы опробовать это, нам понадобится любой сложный объект для кодирования. Для примера вы можете использовать любой пользовательский класс, который вам нравится. Но мы используем для этого встроенный в Python тип [complex](https://www.mathsisfun.com/numbers/complex-numbers.html), который применяется для представления комплексных чисел. И по умолчанию он не сериализуем. 

```shell
>>> z = 3 + 8j
>>> type(z)
<class 'complex'>
>>> json.dumps(z)
TypeError: Object of type 'complex' is not JSON serializable
```


Теперь необходимо задать себе очень важный  вопрос. **Каков минимальный объем информации, нам необходим для воссоздания объекта?** В случае комплексных чисел вам нужно знать значения реальных и мнимых частей числа, которые вы можете получить как атрибуты объекта типа [complex](https://www.mathsisfun.com/numbers/complex-numbers.html):  

```shell
>>> z.real
3.0
>>> z.imag
8.0
```

После передачи чисел, полученных в качестве результата в конструктор  `complex()`  (типа данных комплексное число) оператор сравнения `__eq__` вернёт нам значение `True`:  

```shell
>>> complex(3, 8) == z
True
```

Разбиение данных пользовательских типов до составляющих их элементов с простыми базовыми типами, имеет решающее значение для успешного результата работы процессов сериализации и десериализации.

### Кодирование пользовательских типов данных ###
Для того чтобы преобразовать объект пользовательского типа в формат JSON, вам необходимо предусмотреть функцию кодирования для передачи ее через именованный параметр `default` метода`dump()`. Модуль **json** будет вызывать эту функцию для любых объектов, которые не могут быть сериализованы способом по умолчанию. Вот, например, простая функция декодирования, которую вы можете использовать на практике:  

```python
def encode_complex(z):
    if isinstance(z, complex):
        return (z.real, z.imag)
    else:
        type_name = z.__class__.__name__
        raise TypeError(f"Object of type '{type_name}' is not JSON serializable")  
```

Обратите внимание, на то что вы должны генерировать исключение **TypeError**, если не получите объект ожидаемого типа. Теперь вы сможете попробовать кодировать сложные пользовательские объекты:

```shell
>>> json.dumps(9 + 5j, default=encode_complex)
'[9.0, 5.0]'
>>> json.dumps(elf, default=encode_complex)
TypeError: Object of type 'Elf' is not JSON serializable
```

> **Почему мы кодировали комплексное число как кортеж (*tuple*)?** Хороший вопрос. Это, безусловно, не единственный и не лучший выбор. На самом деле, это не очень хорошее представление данных, в особенности если бы вы захотите позже декодировать, полученный результат. И вы вскоре убедитесь в этом.

Другой общий подход заключается в применении подкласса стандартного класса `JSONEncoder` и переопределении его метода `default()`:  

```python
class ComplexEncoder(json.JSONEncoder):
    def default(self, z):
        if isinstance(z, complex):
            return (z.real, z.imag)
        else:
            super().default(self, z)
```

Вместо того, чтобы генерировать исключения типа **TypeError**, вы можете позволить базовому классу обработать его. Используйте этот прием либо непосредственно при вызове метода `dumps()` через именованный параметр `cls`, либо путем создания экземпляра `encoder` (кодера) и вызова его метода `encode()`:  

```shell
>>> json.dumps(2 + 5j, cls=ComplexEncoder)
'[2.0, 5.0]'

>>> encoder = ComplexEncoder()
>>> encoder.encode(3 + 6j)
'[3.0, 6.0]'
```

### Декодирование пользовательских типов данных ###

Хотя знать значения реальных и мнимых частей комплексного числа необходимо для воссоздания объекта типа `complex` , но на практике этого может оказаться недостаточно. Например, попытаемся кодировать в формате JSON комплексное число с помощью класса `ComplexEncoder` , а затем декодировать результат в виде объекта Python:  

```shell
>>> complex_json = json.dumps(4 + 17j, cls=ComplexEncoder)
>>> json.loads(complex_json)
[4.0, 17.0]
```

Из этого кода видно, что если вы захотите получить объект с типом `complex`, то полученный список значений (*list*) необходимо передать в соответствующий конструктор типа`complex()`. 

Таким образом для достоверного декодирования JSON нам необходимо заранее знать тип данных пользовательского объекта, который должен быть получен.  Что же нам неизвестно еещё? В рассмотренном нами случае отсутствуют **метаданные** или **информация о типе декодируемых данных**.  
Теперь еще раз зададим себе следующий вопрос: **Каков минимальный объем информации, который необходим и достаточен для восстановления этого объекта?**

Модуль **json** ожидает, что все пользовательские типы данных будут отображаться как объекты в стандарте JSON. Для разнообразия вы можете создать файл  JSON на этот раз с именем `complex_data.json` и добавить туда следующий объект, описывающий комплексное число:

```python
{
    "__complex__": true,
    "real": 42,
    "imag": 36
}  
```

Ключ `__complex__`- это метаданные, о которых мы говорили выше. На самом деле не важно с каким значением он ассоциирован. Чтобы этот маленький *хак* работал, все, что вам нужно это проверить существует ли этот ключ:  

```python
def decode_complex(dct):
    if "__complex__" in dct:
        return complex(dct["real"], dct["imag"])
    return dct
```

Если ключа `__complex__` нет в словаре, вы можете просто вернуть объект или осуществить преобразование декодером по умолчанию.  
Каждый раз когда метод `loads()` пытается проанализировать объект `object`, вам предоставляется возможность изменить его поведение перед тем как декодер по умолчанию начнет работать с данными. Вы можете сделать это, передав вашу собственную функцию декодирования через именованный параметр `object_hook`.  
Запустим на выполнение следующий код:  

```shell
>>> with open("complex_data.json") as complex_data:
...     data = complex_data.read()
...     z = json.loads(data, object_hook=decode_complex)
... 
>>> type(z)
<class 'complex'>
```

Хотя параметр `object_hook` может показаться аналогичным параметру `default` метода `dump()`, однако это не так.
Этот код работает не только с одним объектом. Попробуйте поместить список (*list*) объектов комплексных чисел в `complex_data.json` и снова запустить скрипт:  

```json
[
  {
    "__complex__":true,
    "real":42,
    "imag":36
  },
  {
    "__complex__":true,
    "real":64,
    "imag":11
  }
]
```

Если ваш код не содержит ошибок, то вы получите список объектов типа `complex`:

```shell
>>> with open("complex_data.json") as complex_data:
...     data = complex_data.read()
...     numbers = json.loads(data, object_hook=decode_complex)
... 
>>> numbers
[(42+36j), (64+11j)]  
```

Вы также можете попробовать использовать подкласс класса `JSONDecoder` и переопределить его метод `object_hook`, но лучше всего придерживаться самого простого решения.

## Все готово
Поздравляю теперь вы можете использовать всю мощь формата JSON для реализации ваших приложений на языке Python.  

Хотя примеры с которыми мы работали здесь, безусловно, чрезмерно упрощены, но иллюстрируют основы процесса работы с форматом данных JSON. Информация изложенная в этой статье поможет вам решить следующие задачи:  

1. Импорт модуля **json**.  
2. Чтение данных с использованием методов `load()` или `loads()`.  
3. Обработка данных.  
4. Запись измененных данных с помощью методов `dump()` или `dumps()`.

То, что вы будете делать с данными после их загрузки в память, будет зависеть от конкретного варианта использования. Как правило, вашей целью будет получение данных из источника, извлечение и обработка полезной информации, а также дальнейшая передача ее или запись в файл.  

Рассмотрение особенностей использования стандартного модуля **json** упростит вам изучение других модулей Python, использующихся для сериализации данных: [pickle](https://docs.python.org/3/library/pickle.html) и [marshal](https://docs.python.org/3/library/marshal.html).

Удачи вам в дальнейшем изучении языка Python!



