# Преобразование цветовых пространств в JavaScript

В ходе работы над проектом [«эмоджификатора» изображений,](https://codepen.io/jkantner/pen/OoXvMB) я столкнулся с проблемой необходимости изменения вида модели цветового пространства значений, полученных с использованием метода Canvas 2D API [getImageData()](), из **RGB** в **HSL**. Я создавал массивы *emoji* смайликов, сортированных по яркости и насыщенности в цветовом пространстве HSL для лучшего соответствия средних цветов пикселей со смайликами.

В этой статье мы рассмотрим функции, которые будут полезны для преобразования как непрозрачных, так и прозрачных (содержащих *alpha*-каналы) значений цветов. Современные браузеры в настоящее время поддерживают цветовые пространства **RGB(A)**, **hex** и **HSL(A)**. Обозначения функций и типов значений для них следующие: `rgb()`, `rgba()`, `#rgb`/ `#rrggbb`, `#rgba`/ `#rrggbbaa`, `hsl()`и `hsla()`. При этом браузеры всегда поддерживали и поддерживают предопределенные встроенные имена цветов, такие как `aliceblue`.

![Пребразователь пространств цветов](o:\Новая папка\p1.jpg)

Попутно мы столкнемся с использованием некоторых других синтаксисов для задания цвета, предоставляемых новым модулем CSS Colors [Level 4](https://drafts.csswg.org/css-color/) . Теперь например, мы можем  задавать  значение цвета с *alpha*-каналом в шестнадцатеричном виде   `#rgba`/ `#rrggbbaa`, а синтаксисам RGB и HSL больше не требуются запятые для разделения значений составляющих цвета (значения  `rgb(255 0 0)`и `hsl(240 100% 50%)`стали допустимыми!).

> Поддержка **CSS Colors Level 4** браузерами не является полной на момент написания этой статьи, поэтому если вы попробуете применить их в CSS стилях ваших страниц не ожидайте, что новые синтаксисы цветов будут работать в браузерах Microsoft или Safari.



##  Из RGB в Hex

Преобразование значения цвета из цветового пространства **RGB** в формат **hex** - это просто изменение основания системы счисления. Для этого сначала переведем численные значения красного, зеленого и синего цветов модели из десятичного в шестнадцатеричное представление с помощью метода объекта *Number* `toString(16)`. Затем приведем их к строковому типу, добавив символ `0` в начало каждого полученного значения, объединим полученные строки вместе, добавим в начало, полученной строки символ `#` , и вернем ее значение с помощью инструкции `return`. Ниже представлен код, функции реализующей это преобразование.

```javascript
function RGBToHex(r,g,b) {
	r = r.toString(16);
	g = g.toString(16);
	b = b.toString(16);
	if (r.length == 1)
		r = "0" + r;
	if (g.length == 1)
		g = "0" + g;
	if (b.length == 1)
		b = "0" + b;
	return "#" + r + g + b;
}
```



### RGB в String

Также можно использовать в качестве единственного аргумента для функции строку, содержащую значения трех составляющих цвета (красного, зеленого и синего), разделеных запятыми или пробелами (например `"rgb(255,25,2)"`, `"rgb(255 25 2)"`. Реализация функции осуществляющей это преобразование содержит следующие инструкции. 

```javascript
function RGBToHex(rgb) {
	// выбор корректного вида разделителя(запятая или пробел)
	let sep = rgb.indexOf(",") > -1 ? "," : " ";
	// преобразуем "rgb(r,g,b)" в [r,g,b]
	rgb = rgb.substr(4).split(")")[0].split(sep);
	let r = (+rgb[0]).toString(16),
	g = (+rgb[1]).toString(16),
	b = (+rgb[2]).toString(16);
	if (r.length == 1)
		r = "0" + r;
	if (g.length == 1)
		g = "0" + g;
	if (b.length == 1)
		b = "0" + b;
	return "#" + r + g + b;
}
```

Сначала определим вид использующегося разделителя `sep` (запятая или пробел). Удалим подстроку `rgb(`, затем разделим (с помощью метода `split`), то что осталось от строки на подстроки с разделителем `)`. Снова первый элемент полученного массива разделим с использованием разделителя, вид которого мы определии ранее `sep`.  Объявим локальные переменные `r`, `g` и `b`, которым в последствии присвоим значения соответствующих цветов. Используем унарный оператор `+` перед полученными строками, чтобы преобразовать их в числа перед получением соответствующих шестнадцатеричных значений с помощью метода `toString(16)`.

Кроме того, мы можем реализовать ввод строки со значениями цветов по каналам в процентах, добавив цикл после определения массива `rgb`. В цикле удалим символ `%` и преобразуем то, что осталось, в значения из диапазона 0-255.

```javascript
function RGBToHex(rgb) {
	let sep = rgb.indexOf(",") > -1 ? "," : " ";
	rgb = rgb.substr(4).split(")")[0].split(sep);
	// Преобрацуем % в значения из диапазона 0–255
	for (let R in rgb) {
		let r = rgb[R];
		if (r.indexOf("%") > -1)
			rgb[R] = Math.round(r.substr(0,r.length - 1) / 100 * 255);
		/* Пример:
   			75% -> 191
			75/100 = 0.75, \* 255 = 191.25 -> 191
		*/
}
```

Теперь мы можем конвертировать в строку значения в следующих форматах:

- `rgb(255,25,2)`
- `rgb(255 25 2)`
- `rgb(50%,30%,10%)`
- `rgb(50% 30% 10%)`



## RGBA в Hex (#rrggbbaa)

Преобразование цвета в формате **RGBA** в **hex** в нотации `#rgba` или `#rrggbbaa` происходит практически так же, как и его "непрозрачного" аналога. Поскольку *alpha*-канал `a` обычно задается значением от 0 до 1, то нам необходимо умножить его значение на 255, округлить результат, а затем преобразовать в шестнадцатеричную систему исчесления.

```javascript
function RGBAToHexA(r,g,b,a) {
	r = r.toString(16);
	g = g.toString(16);
	b = b.toString(16);
	a = Math.round(a * 255).toString(16);
	if (r.length == 1)
		r = "0" + r;
	if (g.length == 1)
		g = "0" + g;
	if (b.length == 1)
		b = "0" + b;
	if (a.length == 1)
		a = "0" + a;
	return "#" + r + g + b + a;
}
```

Если в качестве параметра функции будет взята строка как в предыдущем примере (в том числе со значениями в процентах), то обработать эту ситуацию мы можем также как делали это ранее. Далее обратите внимание на дополнительную операцию вставки *слеша* (косой черты) `/`. Так как CSS Colors Level 4 поддерживает синтаксис вида `rgba(r g b / a)`, значения *alpha*-канала теперь могут выражаться в процентах!  Таким образом, цикл `for` по массиву `rgba`должен включать в себя часть, чтобы убирающую символ `%` у значения *alpha*-канала, не умножая его на 255. Вскоре мы сможем использовать значения вида`rgba(255 128 0 / 0.8)` так и `rgba(100% 21% 100% / 30%)`!

```javascript
function RGBAToHexA(rgba) {
	let sep = rgba.indexOf(",") > -1 ? "," : " ";
	rgba = rgba.substr(5).split(")")[0].split(sep);
	// Убираем символ слэша если используется синтаксис отделения им значения альфа-канала
	if (rgba.indexOf("/") > -1)
		rgba.splice(3,1);
	for (let R in rgba) {
		let r = rgba[R];
        if (r.indexOf("%") > -1) {
            let p = r.substr(0,r.length - 1) / 100;
            if (R < 3) {
                rgba[R] = Math.round(p * 255);
            } else {
                rgba[R] = p;
            }
        }
	}
}
```

Там где значения каналов цвета конвертируются в **hex**, мы можем также предусмотреть присвоение переменной `a` значения соответствующего элемента массива `rgba[]`.

```javascript
function RGBAToHexA(rgba) {
 // ...
	let r = (+rgba[0]).toString(16),
		g = (+rgba[1]).toString(16),
		b = (+rgba[2]).toString(16),
		a = Math.round(+rgba[3] * 255).toString(16);
	if (r.length == 1)
		r = "0" + r;
	if (g.length == 1)
		g = "0" + g;
	if (b.length == 1)
		b = "0" + b;
	if (a.length == 1)
		a = "0" + a;
	return "#" + r + g + b + a;
}
```

Теперь наша функция поддерживает следующие типы входных параметров:

- `rgba(255,25,2,0.5)`
- `rgba(255 25 2 / 0.5)`
- `rgba(50%,30%,10%,0.5)`
- `rgba(50%,30%,10%,50%)`
- `rgba(50% 30% 10% / 0.5)`
- `rgba(50% 30% 10% / 50%)`

## Hex в RGB

Мы знаем, что длина строк, соответствующих значениям каналов цвета в шестнадцатеричном исчислении, должна быть либо 3, либо 6 символов (плюс `#`). В любом случае мы предваряем каждое значение цвета каналов *red*  `r`, *green*  `g` и *blue*  `b`  символами `"0x"` для того, чтобы преобразовать их в шестнадцатеричное представление. Если мы хотим получить трехзначное значение, мы объединяем одно и то же значение дважды для каждого канала. Если нам необходимо получить шестизначное значение, то мы объединяем первые два значения для красного, следующие два для зеленого и последние два для синего каналов цвета. Для того, чтобы сформировать возвращаемое значение строки в формате `rgb()`, мы предваряем переменные унарным оператором `+` чтобы преобразовать их из строк обратно в числа, что позволит получить нам значения в виде десятичных дробей.

```javascript
function hexToRGB(h) {
	let r = 0, g = 0, b = 0;
	// 3 символа
	if (h.length == 4) {
		r = "0x" + h[1] + h[1];
		g = "0x" + h[2] + h[2];
		b = "0x" + h[3] + h[3];
	// 6 символов
	} else if (h.length == 7) {
		r = "0x" + h[1] + h[2];
		g = "0x" + h[3] + h[4];
		b = "0x" + h[5] + h[6];
	}
	return "rgb("+ +r + "," + +g + "," + +b + ")";
}
```

### Вывод RGB в % 

Если мы захотим вернуться к нотации вида `rgb()`с использованием процентов в значениях цветов каналов, то мы можем изменить функцию, и использовать необязательный параметр `isPct`, например, следующим образом:

```javascript
function hexToRGB(h,isPct) {
	let r = 0, g = 0, b = 0;
		isPct = isPct === true;

	if (h.length == 4) {
		r = “0x” + h[1] + h[1];
		g = “0x” + h[2] + h[2];
		b = “0x” + h[3] + h[3];
	} else if (h.length == 7) {
		r = “0x” + h[1] + h[2];
		g = “0x” + h[3] + h[4];
		b = “0x” + h[5] + h[6];
	}

	if (isPct) {
		r = +(r / 255 * 100).toFixed(1);
		g = +(g / 255 * 100).toFixed(1);
		b = +(b / 255 * 100).toFixed(1);
	}

	return “rgb(“ + (isPct ? r + “%,” + g + “%,” + b + “%” : +r + “,” + +g + “,” + +b) + “)”;
}
```

Внутри блока последней инструкции `if`, с помощью унарного оператора `+` значения переменных `r`, `g`и `b` будут приведены к числовому типу данных. Затем метод `toFixed(1)` округлит результат до десятых. Кроме того, у нас не будет целых чисел с `.0` или причудой десятилетней давности, которая производит такие числа, как `0.30000000000000004`. Таким образом, оператор `return`, мы опустили `+`S непосредственно перед первым `r`, `g`и `b`предотвратить `NaN`, вызванные `%`. Теперь мы можем использовать, `hexToRGB("#ff0",true)`чтобы получить `rgb(100%,100%,0%)`! sdsds