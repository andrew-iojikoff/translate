# Что такое виртуальный DOM

Недавно я уже писала о [DOM](https://bitsofco.de/what-exactly-is-the-dom/) и [shadow DOM](https://bitsofco.de/what-is-the-shadow-dom/), а так же об их различиях. Объектная модель документа (**D**ocument **O**bject **M**odel) - это представление HTML  документа в виде объекта, кроме того она предоставляет интерфейс для управления этим объектом. Теневой “shadow” DOM можно рассматривать как “облегченную“ версию DOM. Это такое же объектное представление отдельных элементов HTML, но при этом не являющееся полностью автономным документом. Вместо этого теневой DOM позволяет нам разделить наш DOM на меньшие отдельные инкапсулированные части, которые затем можно использовать в HTML документах.

Другой схожий, с выше рассмотренными, термин, с которым вы, вероятно, уже сталкивались, это «виртуальный DOM». И хотя эта концепция существует уже несколько лет, но стала она популярной относительно недавно благодаря ее использованию в фреймворке React. В этой статье я расскажу, что такое виртуальный DOM, чем он отличается от “реального“, а также как он применяется на практике.

## Зачем нам нужен виртуальный DOM?

Для того, что бы понять, почему возникла концепция виртуального DOM, давайте вернемся к представлению DOM обычного HTML документа. И как уже говорилось выше, он включает в себя две составляющие - объектное представление документа HTML и API для управления этим объектом.   

Для примера, возьмем простой HTML документ, содержащий неупорядоченный список с одним элементом.

```html
<!doctype html>
<html lang="en">
 <head></head>
 <body>
    <ul class="list">
        <li class="list__item">List item</li>
    </ul>
  </body>
</html>
```

Этот документ может быть представлен в виде дерева DOM следующего вида:

![Вид дерева DOM](D:\###temp\translate\Understanding the Virtual DOM\DOM.PNG)

Допустим мы захотим изменить текстовое содержимое первого (и единственного) элемента списка на следующее “List item one”, а также добавить в список второй элемент с произвольным содержимым. Для этого необходимо использовать API DOM, чтобы найти те элементы которые мы хотим обновить, создать новые элементы, добавить им атрибуты и содержимое, а затем обновить существующее дерево DOM с учетом изменений.

```js
const listItemOne = document.getElementsByClassName("list__item")[0];
listItemOne.textContent = "List item one";

const list = document.getElementsByClassName("list")[0];
const listItemTwo = document.createElement("li");
listItemTwo.classList.add("list__item");
listItemTwo.textContent = "List item two";
list.appendChild(listItemTwo);
```



### DOM не был создан для этого…

В те времена когда вышла [первая спецификация DOM в 1998 году](https://www.w3.org/TR/REC-DOM-Level-1/), все создавали вебстраницы и управляли их содержимым по разному. В то время мало полагались на API DOM для создания и обновления содержимого вебстраниц, по крайней мере не так часто как мы это делаем сейчас.   

При этом такие методы как `document.getElementsByClassName()` хорошо использовать для простых задач. Но если мы хотим обновлять большое количество элементов на странице каждые несколько секунд, то это может стать дорогой, с точки зрения производительности, процедурой: постоянно запрашивать и обновлять элементы DOM.

Таким образом, из-за особенностей реализации API DOM, обычно проще (и выгоднее из-за общей производительности выполнения кода) выполнять более “дорогие” операции по обновлению больших частей DOM, чем осуществлять поиск и обновление (изменение) каждого элемента DOM по отдельности. 

Вернемся к нашему примеру, а точнее к списку. Исходя из выше сказанного, самым легким (и экономичным) способом решения нашей задачи является замена всего содержимого нашего неупорядоченного списка новым, чем модифицировать его отдельные элементы.

```js
const list = document.getElementsByClassName("list")[0];
list.innerHTML = `
<li class="list__item">List item one</li>
<li class="list__item">List item two</li>
`;
```

В этом конкретном примере разница в производительности между двумя рассмотренными способами будет вероятно незначительна. Однако с увеличением размера страницы и частоты обновления информации она станет более существенной, и выбор последнего рассмотренного способа для обновления содержимого страницы станет тем, что нам действительно нужно.

### … но для этого существует виртуальный DOM

Виртуальный DOM был создан для решения проблем, связанных с необходимостью частого обновления дерева DOM, способом с большей производительностью. В отличие от “классического” DOM и теневого “shadow” DOM, виртуальный DOM не является официальной спецификацией, а представляет собой новый метод взаимодействия с DOM HTML документа.

Виртуальный DOM может рассматриваться как копия исходного DOM (или его части). Этой копией можно манипулировать и обновлять с какой угодно частотой, не используя API DOM нашей страницы. После того как все обновления виртуального DOM были произведены, мы можем решить, какие конкретные изменения необходимо внести в “реальный” DOM, и сделать это единовременно оптимальным способом.

## Как выглядит виртуальный DOM?

Название «виртуальный DOM» добавляет немножко магии к загадке, что же на самом деле представляет собой эта концепция? Фактически, виртуальный DOM - это просто обычный объект Javascript.

Давайте вернемся к дереву DOM, которое мы создали ранее:

![Вид дерева DOM](D:\###temp\translate\Understanding the Virtual DOM\DOM.PNG)



Это дерево может быть также представлено как литерал объекта Javascript.

```js
const vdom = {
    tagName: "html",
    children: [
        { tagName: "head" },
        {
            tagName: "body",
            children: [
                {
                    tagName: "ul",
                    attributes: { "class": "list" },
                    children: [
                        {
                            tagName: "li",
                            attributes: { "class": "list__item" },
                            textContent: "List item"
                        } // end li
                    ]
                } // end ul
            ]
        } // end body
    ]
} // end html
```

Мы можем рассматривать этот объект как наш виртуальный DOM. Как и исходный “классический” DOM, это объектное представление нашего HTML документа или его части. Но так как это простой объект Javascript, мы можем свободно и как угодно часто манипулировать им, не касаясь реального DOM, пока нам это не понадобится.

Вместо того, чтобы использовать один объект для всего объекта HTML документа, более распространенной практикой является работа с несколькими отдельными частями виртуального DOM. Например, мы можем работать с отдельным компонентом `list`, который будет непосредственно привязан к элементу (узлу) нашего неупорядоченного списка.

```js
const list = {
    tagName: "ul",
    attributes: { "class": "list" },
    children: [
        {
            tagName: "li",
            attributes: { "class": "list__item" },
            textContent: "List item"
        }
    ]
};
```



## Под капотом виртуального DOM

Теперь, когда мы рассмотрели, что же собой представляет виртуальный DOM, разберемся как он применяется для решения проблемы удобства управления и повышения производительности обновления “реального” DOM.

Как я уже упоминала, мы можем использовать виртуальный DOM для отделения конкретных изменений элементов, которые необходимо сделать в "реальном" DOM, а затем изолированно изменять их в виртуальном DOM. Теперь, давайте вернемся к нашему неупорядоченному списку и внесем те же изменения, что и в “реальном” DOM.

Первое, что мы для этого сделаем, это сделаем копию - виртуальный DOM, содержащую изменения, которые мы хотим сделать. Поскольку нам не нужно для этого использовать API DOM, мы просто создаем новый объект следующего вида.

```js
const copy = {
    tagName: "ul",
    attributes: { "class": "list" },
    children: [
        {
            tagName: "li",
            attributes: { "class": "list__item" },
            textContent: "List item one"
        },
        {
            tagName: "li",
            attributes: { "class": "list__item" },
            textContent: "List item two"
        }
    ]
};
```

Этот объект `copy` используется для создания того, что называется `diff` (разницы) между исходным и виртуальным DOM, в данном случае элементом `list`, и его измененным представлением в виртуальном DOM. `diff` может выглядеть примерно так:

```js
const diff = [
    {
        newNode: { /* новая версия элемента списка */ },
        oldNode: { /* исходная версия элемента списка */ },
        index: /* индекс элемента в родительском списке */
    },
    {
        newNode: { /* второй элемент списка */ },
        index: { /* */ }
    }
]
```

Полученные выше различия `diff` представляют собой инструкции по обновлению исходного DOM. Как только все различия собраны вместе, мы можем пакетно вносить изменения в DOM нашей страницы, делая только необходимые обновления ее содержимого.

Далее мы можем перебрать каждое изменение `diff` в цикле, то есть добавить элементу списка нового потомка или же обновить содержимое старого в зависимости от того, что указано в `diff`.

```js
const domElement = document.getElementsByClassName("list")[0];

diff.forEach((diff) => {

    const newElement = document.createElement(diff.newNode.tagName);
    /* добавим атрибуты ... */
    
    if (diff.oldNode) {
        // Если есть старая версия заменить ее новой
        domElement.replaceChild(diff.newNode, diff.index);
    } else {
        // Если нет старой версии, создать новый элемент node
        domElement.appendChild(diff.newNode);
    }
})
```

Обратите внимание, что это упрощенная и сильно урезанная версия того, как может работать виртуальный DOM, и есть много нюансов, которые не рассматриваются в этой статье.



## Виртуальный DOM и фреймворки

Наиболее часто концепция виртуального DOM применяется в фреймворках. Не используя эту концепцию непосредственно, как это показано в примере выше. Рассмотрим как React используют концепцию виртуального DOM для реализации более производительных обновлений DOM. Например, наш список `list` как компонент в React может быть представлен следующим образом.

```js
import React from 'react';
import ReactDOM from 'react-dom';

const list = React.createElement("ul", { className: "list" },
    React.createElement("li", { className: "list__item" }, "List item")
);

ReactDOM.render(list, document.body);
```

Если бы мы захотели обновить содержимое нашего списка, то мы должны просто изменить шаблон (template) списка и снова вызвать метод `ReactDOM.render()`, передав ему в качестве аргумента новый список.

```js
const newList = React.createElement("ul", { className: "list" },
    React.createElement("li", { className: "list__item" }, "List item one"),
    React.createElement("li", { className: "list__item" }, "List item two");
);

setTimeout(() => ReactDOM.render(newList, document.body), 5000);
```

Поскольку React использует виртуальный DOM, то даже если мы перерисовываем всю страницу, обновляются только те части, которые действительно необходимо изменить. Если мы посмотрим на это в действии с помощью инструментов разработчика (developer tools) браузера, то увидим следующее. Когда производятся изменения Html документа, то мы увидим что обновляются отдельные элементы или конкретные части страницы, не изменяя всего ее содержимого.

Видео - https://res.cloudinary.com/ireaderinokun/video/upload/v1545416044/bitsofcode/react-virtual-dom.webm



## DOM vs. виртуальный DOM

Напомним, что виртуальный DOM - это инструмент, который позволяет нам взаимодействовать с элементами DOM более простым и производительным способом. Это представление DOM в виде Javascript объекта, который мы можем изменять так часто, как нам нужно. Изменения, внесенные в этот объект, сопоставляются с прежней версией исходного DOM страницы или ее части. А затем изменяются только те ее отдельные части, которые необходимо обновить. Таким образом обращение к элементам страницы, а также их изменение в "реальном" DOM производятся реже, что непосредственно влияет на конечную производительность нашего кода.

