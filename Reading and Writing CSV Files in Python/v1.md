# Чтение и запись CSV файлов в Python #

Посмотрим правде в глаза: вам нужно получать информацию из своих программ не только через клавиатуру и консоль. Обмен информацией через текстовые файлы является самым распространенным способом обмена информацией между программами. Одним из самых популярных форматов обмена данными является формат CSV. Но как вы его используете?  

Давайте поймем одно: вам не нужно (и вы не будете) создавать свой собственный синтаксический анализатор (парсер) файлов в формате CSV с нуля. Существует несколько подходящих библиотек, которые вы можете использовать для этих целей. Python библиотеки [csv](https://docs.python.org/3/library/csv.html) будет достаточно в большинстве случаев. Если ваша работа требует большого количества данных и использует численный анализ, то в библиотеке [pandas](http://pandas.pydata.org/) также есть возможности синтаксического анализа файлов в формате CSV, которые должны будут позже будут обработаны.

В этой статье вы узнаете, как читать, обрабатывать и анализировать CSV из текстовых файлов с помощью Python. Вы увидите, файлы CSV в работе, изучите все самое важной в библиотеке [csv](https://docs.python.org/3/library/csv.html), встроенной в Python, и посмотрите, как работает синтаксический анализ CSV (парсинг) с использованием библиотеки [pandas](http://pandas.pydata.org/).  

 Давайте начнем!

## Что такое файл в формате CSV ##  
CSV-файл (Comma Separated Values file - файл со значениями разделительными запятыми) представляет собой тип простого текстового файла, который использует специальную структуризацию для организации табличных данных. Поскольку это простой текстовый файл, он может содержать только строчные текстовые данные, другими словами, печатные символы [ASCII](https://en.wikipedia.org/wiki/ASCII) или [Unicode](https://en.wikipedia.org/wiki/Unicode).   
Структура CSV-файла определяется его названием. Обычно CSV-файлы используют запятую для разделения каждого конкретного значения данных. Вот как выглядит эта структура:

	column 1 name,column 2 name, column 3 name
	first row data 1,first row data 2,first row data 3
	second row data 1,second row data 2,second row data 3
	...

Обратите внимание, что каждая часть данных разделяется запятой. Обычно первая строка идентифицирует каждый фрагмент данных, другими словами, это имя столбца данных. Каждая последующая строка после этого является фактическими данными и ограничена только ограничениями размерами файла.   
В общем случае разделяющий значения символ называется разделителем, а запятая не является единственным символом, который может использоваться в качестве разделителя. Другие популярные символы, использующиеся в качестве разделителя: *tab* (*\t*), двоеточие ( : ) и  точка с запятой ( ; ). Правильный синтаксический анализ (парсинг) CSV-файла требует от нас знать, какой разделитель используется в этом файле.  

### Откуда появились CSV файлы?

Файлы CSV обычно создаются программами, которые обрабатывают большие объемы данных. Они представляют собой удобный способ экспортировать данные из электронных таблиц и баз данных, а также импортировать их и использовать в других программах. Например, вы можете экспортировать результаты работы программы статистического анализа данных в файл CSV, а затем импортировать их в электронную таблицу для дальнейшего анализа, построения графиков для презентации или подготовки отчета для публикации.   

Файлы CSV очень просты и удобны при работе с прикладным программным обеспечением. Любой язык, поддерживающий ввод текстовых файлов и манипулирование строками (например, Python), может напрямую работать с файлами CSV.

	
## Разбор (парсинг) CSV-файлов с помощью встроенной в Python библиотекой для обработки CSV данных

Библиотека [csv](https://docs.python.org/3/library/csv.html) предлагает нам функционал как чтения и для записи данных в файлы CSV. Разработанная для работы с CSV-файлами, созданными в Excel, она также легко адаптируется для работы с различными форматами CSV. Библиотека [csv](https://docs.python.org/3/library/csv.html) содержит объекты и методы для чтения и обработки данных из CSV-файлов, а также записи в них.


### Чтение CSV файлов с помощью библиотеки *csv*  

Чтение из файла CSV выполняется с использованием объекта *reader*. CSV-файл открывается как обычный текстовый файл с встроенной в Python функцией *open()*, которая возвращает объект типа файл. Затем это этот объект передается объекту *reader*.

Возьмем например файл *employee_birthday.txt* со следующим содержимым:

	name,department,birthday month
	John Smith,Accounting,November
	Erica Meyers,IT,March

Вот код для его чтения:

	import csv

	with open('employee_birthday.txt') as csv_file:
	    csv_reader = csv.reader(csv_file, delimiter=',')
	    line_count = 0
	    for row in csv_reader:
	        if line_count == 0:
	            print(f'Column names are {", ".join(row)}')
	            line_count += 1
	        else:
	            print(f'\t{row[0]} works in the {row[1]} department, and was born in {row[2]}.')
	            line_count += 1
	    print(f'Processed {line_count} lines.')

Его выполнение приведет к следующему результату:

	Column names are name, department, birthday month
	    John Smith works in the Accounting department, and was born in November.
	    Erica Meyers works in the IT department, and was born in March.
	Processed 3 lines.

Каждая строка, возвращаемая объектом *reader*, представляет собой список элементов типа *String*, содержащих данные, с удаленными разделителями. Первая строка возвращает имена столбцов, которые обрабатываются особым образом.

### Чтение CSV файлов в словарь *dict* с помощью библиотеки *csv*  

Вместо того, чтобы иметь дело со списком отдельных элементов *String*, вы можете считывать данные CSV непосредственно в словарь (технически в [Ordered Dictionary](https://docs.python.org/3/library/collections.html#collections.OrderedDict)).

Наш входной файл *employee_birthday.txt* будет выглядеть следующим образом:

	import csv
	
	with open('employee_birthday.txt', mode='r') as csv_file:
	    csv_reader = csv.DictReader(csv_file)
	    line_count = 0
	    for row in csv_reader:
	        if line_count == 0:
	            print(f'Column names are {", ".join(row)}')
	            line_count += 1
	        print(f'\t{row["name"]} works in the {row["department"]} department, and was born in {row["birthday month"]}.')
	        line_count += 1
	    print(f'Processed {line_count} lines.')

Это приведет к тому же результату, что и раньше:

	Column names are name, department, birthday month
	    John Smith works in the Accounting department, and was born in November.
	    Erica Meyers works in the IT department, and was born in March.
	Processed 3 lines.

Откуда взялись значения ключей для словаря? Предполагается, что первая строка файла CSV содержит ключи для создания словаря. Если их нет в вашем CSV-файле, вы должны указать свои собственные ключи, установив необязательный параметр *fieldnames* в виде списка, содержащего их.

### Необязательные параметры объекта *reader* библиотеки *csv* 

Объект *reader* может обрабатывать различные виды файлов CSV, указывая [дополнительные параметры](https://docs.python.org/3/library/csv.html?highlight=csv#csv-fmt-params), некоторые из которых показаны ниже:

- *delimiter* указывает символ, используемый для разделения каждого поля. По умолчанию используется запятая (',').
- *quotechar* указывает символ, используемый для окружения полей, содержащих символ разделителя. По умолчанию используются двойные кавычки (' " ').
- *escapechar* указывает символ, используемый для экранирования символа разделителя, если кавычки не используются. Значение по умолчанию *escape* символ экранирования отсутствует.

Применение этих параметров требует объяснения. Предположим, вы работаете со следующим файлом *employee_addresses.txt*:

	name,address,date joined
	john smith,1132 Anywhere Lane Hoboken NJ, 07030,Jan 4
	erica meyers,1234 Smith Lane Hoboken NJ, 07030,March 2

Этот CSV файл содержит три поля: имя, адрес и дата присоединения, разделенные запятыми. Проблема в том, что данные для поля адреса также содержат запятую, для того чтобы обозначить почтовый индекс.

Существует три различных способа справиться с этой ситуацией:

- **Использовать другой разделитель**. Таким образом, запятая может безопасно использоваться в самих данных. Вы используете необязательный параметр *delimiter*, чтобы указать новый разделитель.
- **Обернуть данные поля в кавычки**. Специальный тип выбранного вами разделителя игнорируется в цитируемых (обернутых в кавычки) строках. Поэтому вы можете указать символ, используемый для цитирования (обертывания) с необязательным параметром *quotechar*. Пока этот символ не отображается в данных поля, все будет нормально.
- **Экранирование символа разделителя *delimiter* в данных поля**. Экранирующие *escape* символы работают так же, как в форматированных строках, не позволяя интерпретацию символа, который экранируется (в данном случае символа разделителя *delimiter*). Если используется *escape* символ, его необходимо указать с помощью необязательного параметра *escapechar*.


### Запись CSV файлов с помощью библиотеки *csv*

Вы можете записать в CSV файл, используя объект *writer* и метод *write_row()*:

	import csv
	
	with open('employee_file.csv', mode='w') as employee_file:
	    employee_writer = csv.writer(employee_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
	
	    employee_writer.writerow(['John Smith', 'Accounting', 'November'])
	    employee_writer.writerow(['Erica Meyers', 'IT', 'March'])

Необязательный параметр *quotechar* указывает объекту *writer*, какой символ использовать для определения (цитирования) полей при записи (например, обернуть значение поля в кавычки). Однако, используется ли цитирование или нет, определяется необязательным параметром *quoting*:
- Если для цитирования *quoting* задано значение *csv.QUOTE_MINIMAL*, то *.writerow()* при записи цитировать поля (например, оборачивать в кавычки) только в том случае, если они содержат разделитель или *quotechar*. Это случай по умолчанию.
- Если для цитирования *quoting* задано значение *csv.QUOTE_ALL*, то *.writerow()* будет цитировать все поля.
- Если для цитирования *quoting* установлено значение *csv.QUOTE_NONNUMERIC*, то *.writerow()* будет цитировать все поля, содержащие текстовые данные, и преобразовывать все числовые поля в тип данных *float*.
- Если для цитирования *quoting* задано значение *csv.QUOTE_NONE*, то *.writerow()* будет экранировать разделители вместо цитирования. В этом случае вы также должны указать значение для необязательного параметра *escapechar*.

Чтение файла обратно в простой текстовый вид показывает, что созданный файл будет следующим:

	John Smith,Accounting,November
	Erica Meyers,IT,March

### Запись CSV файла из словаря *dictionary* с помощью библиотеки *csv*

Поскольку вы можете читать данные из словаря, справедливо, что вы также сможете записывать их из словаря:

	import csv

	with open('employee_file2.csv', mode='w') as csv_file:
	    fieldnames = ['emp_name', 'dept', 'birth_month']
	    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
	
	    writer.writeheader()
	    writer.writerow({'emp_name': 'John Smith', 'dept': 'Accounting', 'birth_month': 'November'})
	    writer.writerow({'emp_name': 'Erica Meyers', 'dept': 'IT', 'birth_month': 'March'})

В отличие от класса *DictReader*, для работы класса *DictWriter* требуется параметр *fieldnames* при записи данных из словаря в файл. Без списка имен полей *fieldnames* *DictWriter* не сможет узнать, какие ключи использовать для извлечения значений из ваших словарей. Он также использует имена ключей для записи первой строки в качестве имен полей столбцов.

Приведенный выше код генерирует следующий выходной файл:

	emp_name,dept,birth_month
	John Smith,Accounting,November
	Erica Meyers,IT,March

##Синтаксический анализ (парсинг) CSV файлов с помощью библиотеки *pandas*

Конечно, библиотека Python [csv](https://docs.python.org/3/library/csv.html) - не единственная в своем роде. Чтение CSV файлов возможно и с помощью библиотеки [pandas](http://pandas.pydata.org/index.html). Это настоятельно рекомендуется, если у вас есть очень много данных для анализа. 

[pandas](http://pandas.pydata.org/index.html) - это библиотека Python с открытым исходным кодом, которая предоставляет высокопроизводительные инструменты анализа данных и простые в использовании структуры данных. *pandas* доступна для всех версий Python, она является основной частью дистрибутива [Anaconda](https://anaconda.org/anaconda/python) и хорошо работает совместно с [Jupyter notebooks](https://jupyter.org/) для обмена данными, кодом, результатами анализа, с использованием визуализации и сопутствующим описанием.

Установка *pandas* и его зависимостей в *Anaconda* выполняется легко:

	$ conda install pandas

Также с использованием *pip/pipenv* другого установщика пакетов Python:

	$ pip install pandas

Мы не будем вникать в особенности того, как работает *pandas* или как ее использовать. Для углубленного изучения использования *pandas* для чтения и анализа больших наборов данных ознакомьтесь с превосходной статьей Shantnu Tiwari [О работе с большими файлами Excel в *pandas*](https://realpython.com/team/stiwari/).

###Чтение файлов CSV с *pandas*

Чтобы показать некоторые возможности *pandas* по работе с CSV, я создал более сложный файл для чтения и назвал его *hrdata.csv*. Он содержит данные о сотрудниках компании:

	Name,Hire Date,Salary,Sick Days remaining
	Graham Chapman,03/15/14,50000.00,10
	John Cleese,06/01/15,65000.00,8
	Eric Idle,05/12/14,45000.00,10
	Terry Jones,11/01/13,70000.00,3
	Terry Gilliam,08/12/14,48000.00,7
	Michael Palin,05/23/13,66000.00,8

Чтение CSV файла с использованием *pandas* класса *DataFrame* происходит просто:

	import pandas
	df = pandas.read_csv('hrdata.csv')
	print(df)

Это все: три строки кода и только одна из них выполняет фактическую работу.
*pandas.read_csv()* открывает, анализирует и читает предоставленный CSV-файл, сохраняет данные в структуру данных класса *DataFrame*. Печать структуры данных *DataFrame* выведет следующее:

	             Name Hire Date   Salary  Sick Days remaining
	0  Graham Chapman  03/15/14  50000.0                   10
	1     John Cleese  06/01/15  65000.0                    8
	2       Eric Idle  05/12/14  45000.0                   10
	3     Terry Jones  11/01/13  70000.0                    3
	4   Terry Gilliam  08/12/14  48000.0                    7
	5   Michael Palin  05/23/13  66000.0                    8

Вот несколько соображений:

- Во-первых, *pandas* распознала, что первая строка CSV содержит имена столбцов и автоматически использует их. Я называю это великим Добром.
- Тем не менее, *pandas* также использует, начинающиеся с нуля, целочисленные индексы в *DataFrame*. Это потому, что мы не определили, какими должны быть индексы.
- Кроме того, если вы посмотрите на типы данных наших столбцов, вы увидите, что *pandas* правильно преобразовала значения столбцов *Salary* and *Sick Days* в числа, но столбец *Hire Date* по-прежнему остался строкой *String*. Это легко проверить в интерактивном режиме:


	>>> print(type(df['Hire Date'][0]))
	<class 'str'>

> Индексы - это специальные структуры в базах данных, которые позволяют ускорить поиск и сортировку по определенному полю или набору полей в таблице, а также используются для обеспечения уникальности данных. Проще всего индексы сравнить с указателями в книгах. Если нет указателя, то нам придется просмотреть всю книгу, чтобы найти нужное место, а с указателем то же действие можно выполнить намного быстрее.

Давайте решать эти проблемы по одной. Чтобы использовать один из столбцов столбец в качестве индекса *DataFrame*, добавьте необязательный параметр *index_col*:

	import pandas
	df = pandas.read_csv('hrdata.csv', index_col='Name')
	print(df)

Теперь поле *Name* - наш индекс в структуре данных *DataFrame*:

	               Hire Date   Salary  Sick Days remaining
	Name                                                  
	Graham Chapman  03/15/14  50000.0                   10
	John Cleese     06/01/15  65000.0                    8
	Eric Idle       05/12/14  45000.0                   10
	Terry Jones     11/01/13  70000.0                    3
	Terry Gilliam   08/12/14  48000.0                    7
	Michael Palin   05/23/13  66000.0                    8

Теперь давайте исправим тип данных поля «Hire Date». Вы можете заставить *pandas* читать значения полей данных как дату, используя необязательный параметр *parse_dates*, который определяется как список *list* имен столбцов для обработки в формате дат:

	import pandas
	df = pandas.read_csv('hrdata.csv', index_col='Name', parse_dates=['Hire Date'])
	print(df)

Обратите внимание на разницу в выходе:

	                Hire Date   Salary  Sick Days remaining
	Name                                                   
	Graham Chapman 2014-03-15  50000.0                   10
	John Cleese    2015-06-01  65000.0                    8
	Eric Idle      2014-05-12  45000.0                   10
	Terry Jones    2013-11-01  70000.0                    3
	Terry Gilliam  2014-08-12  48000.0                    7
	Michael Palin  2013-05-23  66000.0                    8

Теперь дата отформатирована правильно, что легко проверяется в интерактивном режиме:

	>>> print(type(df['Hire Date'][0]))
	<class 'pandas._libs.tslibs.timestamps.Timestamp'>

Если ваши CSV файлы не имеют имен столбцов в первой строке, вы можете использовать необязательный параметр *names* для предоставления списка *list* имен столбцов. Вы также можете использовать эту возможность, если хотите переопределить имена столбцов, указанных в первой строке вашего файла. В этом случае вы должны указать методу *pandas.read_csv()*, чтобы игнорировать существующие имена столбцов, используя необязательный параметр *header=0*:

	import pandas
	df = pandas.read_csv('hrdata.csv', 
	            index_col='Employee', 
	            parse_dates=['Hired'], 
	            header=0, 
	            names=['Employee', 'Hired','Salary', 'Sick Days'])
	print(df)

Обратите внимание, что поскольку имена столбцов изменены, столбцы, указанные в необязательных параметрах *index_col* и *parse_dates*, также должны быть изменены. Теперь это приведет к следующему результату:

	                    Hired   Salary  Sick Days
	Employee                                     
	Graham Chapman 2014-03-15  50000.0         10
	John Cleese    2015-06-01  65000.0          8
	Eric Idle      2014-05-12  45000.0         10
	Terry Jones    2013-11-01  70000.0          3
	Terry Gilliam  2014-08-12  48000.0          7
	Michael Palin  2013-05-23  66000.0          8


### Запись CSV файлов с помощью *pandas*

Конечно, если вы не сможете снова получить свои данные *pandas*, это не принесет вам много пользы. Запись *DataFrame* в CSV-файл так же просто, как чтение одного. Давайте запишем данные с новыми именами столбцов в новый файл CSV: 

	import pandas
	df = pandas.read_csv('hrdata.csv', 
	            index_col='Employee', 
	            parse_dates=['Hired'],
	            header=0, 
	            names=['Employee', 'Hired', 'Salary', 'Sick Days'])
	df.to_csv('hrdata_modified.csv')

Единственное различие между этим кодом и приведенным выше для чтения данных из файла заключается в том, что вызов *print(df)* был заменен на *df.to_csv()*, указав имя файла. Новый CSV файл будет выглядеть так:

	Employee,Hired,Salary,Sick Days
	Graham Chapman,2014-03-15,50000.0,10
	John Cleese,2015-06-01,65000.0,8
	Eric Idle,2014-05-12,45000.0,10
	Terry Jones,2013-11-01,70000.0,3
	Terry Gilliam,2014-08-12,48000.0,7
	Michael Palin,2013-05-23,66000.0,8

## Выводы

Если вы поймете основы работы с CSV файлами, то когда вам нужно будет импортировать данные, вы уже будете вооружены этими знаниями. Большинство задач чтения, обработки и записи CSV могут быть легко решены использованием встроенной в Python библиотеку *csv*. Если у вас много данных для чтения и обработки, библиотека *pandas* обеспечивает быструю и удобную работу с данными в формате CSV.

Существуют ли другие способы анализа текстовых файлов? Конечно! Это такие библиотеки, как [ANTLR](http://www.antlr.org/), [PLY](http://www.dabeaz.com/ply/) и [PlyPlus](https://pypi.org/project/PlyPlus/), могут помочь при технической реализации сложного синтаксического анализа (парсинга), а если простые манипуляции с *String* не будут работать, то всегда есть регулярные выражения. Но это темы для других статей ...

