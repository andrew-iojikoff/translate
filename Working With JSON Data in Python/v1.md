#Работа с данными в формате JSON в Python#

С момента своего создания [JSON](https://en.wikipedia.org/wiki/JSON) быстро стал стандартом де-факто для организации обмена информацией. Скорее всего, вы читаете эту статью, потому что вам нужно передавать куда либо некоторые данные. Возможно, вы собираете информацию через API вашего приложения и затем сохраняете свои данные в базе данных. Так или иначе, ты добрался до JSON, и необходимо обработать данные с помощью Python.   
К счастью, это довольно распространенная задача, как и в большинстве подобных задач, Python делает ее почти пренебрежительно легкой. Не бойся, товарищ Питоньеры и Питонисты. Это будет легче легкого!  

> Итак, мы используем JSON для хранения и обмена данными? Так точно! Это не что иное, как стандартизованный формат, который сообщество разработчиков использует для передачи данных.Имейте в виду, что JSON - не единственный формат, доступный для такого рода задач, однако только [XML](https://en.wikipedia.org/wiki/XML) и [YAML](http://yaml.org/), вероятно, являются единственными другими, которые стоит упомянуть в первую очередь.  

## (Очень) Краткое введение в JSON ##
Не удивительно, что **J**ava**S**cript **O**bject **N**otation создавался под вдохновением подмножества языка программирования JavaScript, и связан своим синтаксисом с описанием объектного литерала в JavaScript. Существует [отличный сайт](https://www.json.org/), который поясняет все это. Не волнуйтесь: JSON уже давно стал агностиком языка и существует как [собственный стандарт](https://tools.ietf.org/html/rfc8259), поэтому мы можем с удовольствием избежать обсуждения JavaScript в этой дискуссии.  
В конечном итоге сообщество разработчиков в целом приняло JSON, потому что его легко создавать и понимать людям и машинам.

## Внимание, это JSON! ##
Приготовьтесь. Я собираюсь показать вам реальную жизнь JSON - точно так же, как вы можете наблюдать ее в дикой природе. Внимание: файлы в формате JSON будут доступны для чтения всем, кто использует язык C-стиля, а Python - язык C-стиля ... так что это вы!

	{
	    "firstName": "Jane",
	    "lastName": "Doe",
	    "hobbies": ["running", "sky diving", "singing"],
	    "age": 35,
	    "children": [
	        {
	            "firstName": "Alice",
	            "age": 6
	        },
	        {
	            "firstName": "Bob",
	            "age": 8
	        }
	    ]
	} 

Как вы можете видеть, JSON поддерживает примитивные типы, такие как строки и числа, а также сложные типы данных, такие как списки и объекты с произвольной вложенностью.

> Это похоже на словарь Python. На данный момент это универсальная нотация для описания объектов.

## Python поддерживает JSON изначально! ##

Python поставляется с стандартным (встроенным) модулем [json](https://docs.python.org/3/library/json.html) для кодирования и декодирования данных в формате JSON.  
Просто вставьте вверху вашего файла следующее:

	import json

### Маленький словарь ###
Процесс кодирования JSON обычно называются **сериализацией** (serialization). Этот термин относится к преобразованию данных в последовательность байтов для хранения или передачи по сети.
Вы также можете услышать термин «маршалинг» (marshaling), но это тема для еще одной [дискуссии](https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling). Естественно, **десериализация** (deserialization) является обратным процессом декодирования данных, которые были сохранены или представлены в формате JSON.

> Так это звучит на техническом языке. Но на самом деле все, о чем мы говорим, - это чтение и запись данных. Думайте об этом так: кодирование предназначено для записи данных на диск, а декодирование - для чтения данных в память.

### Сериализация JSON ###

Что происходит после того, как компьютер обработает много информации? Он должен записать дамп данных. Соответственно, модуль **json** предоставляет метод *dump()* для записи данных в файл. Существует также метод *dumps()* для записи в строку Python.  
Простые объекты Python переводятся в JSON в соответствии с довольно интуитивным правилом для преобразования. Правила для преобразования представлены в таблице ниже.   

Python | JSON
------------- | -------------
dict  | объект
list, tuple  | массив
str  | строка
int, long, float  | число
True  | true
False  | false
None  |  null


### Пример простой процедуры сериализации данных###

Представьте, что вы работаете с объектом Python в памяти, который выглядит примерно так:
   
	data = {
	    "president": {
	        "name": "Zaphod Beeblebrox",
	        "species": "Betelgeusian"
	    }
	}  

Важно сохранить эту информацию на диске, поэтому ваша задача - записать ее в файл.   
Используя диспетчер контекстов Python, вы можете создать файл с именем data_file.json и открыть его в режиме записи. (Файлы JSON заканчиваются расширением .json.)  

	with open("data_file.json", "w") as write_file:
	    json.dump(data, write_file)  

Обратите внимание, что *dump()* принимает два позиционных аргумента: (1) объект данных, подлежащий сериализации, и (2) файлоподобный объект, в который будут записываться байты данных.   
Или, если вы так хотите продолжать использовать эти сериализованные данные в формате JSON в своем приложении далее, вы можете записать их в нативный объект Python типа *str* (строка).  

	json_string = json.dumps(data)  

Обратите внимание, что файлоподобный объект отсутствует, так как вы на самом деле не записываете данные на диск. Кроме этой особенности, функция *dumps()* аналогична *dump()*.


###  Некоторые полезные именованные аргументы  ###

Помните, что JSON должен быть легко читаемым людьми, но читаемого синтаксиса недостаточно, если все будет сплющено вместе (упаковано в одну строку без отступов и разделения по строкам). Кроме того, у вас, вероятно, свой стиль форматирования и вам может быть проще читать код, отформатированный по вашему вкусу.

> **ПРИМЕЧАНИЕ.** Оба метода *dump()* и *dumps()* используют одни и те же именованные аргументы.

Первый вариант, который большинство людей хочет изменить, - это количество пробельных символов. Вы можете использовать именованный аргумент *indent*, чтобы указать размер отступа для вложенных структур. Заметьте разницу, используя данные, которые мы определили выше, выполнив следующие команды в консоли:  

	>>> json.dumps(data)
	>>> json.dumps(data, indent=4)

Другой вариант форматирования - это именованный аргумент *separators*. По умолчанию это ряд (строка) из двух частей, разделительных строками (", ", ": "), но обычной альтернативой для более компактного вида JSON является (",", ":"). Взгляните на пример JSON выше еще раз, чтобы увидеть, как вид разделителей изменит общую картину.  


### Десериализация JSON ###  
В модуле **json** вы найдете функции *load()* и *load()* для преобразования кодированных в JSON данных в объекты Python.  
Подобно сериализации, существует простая таблица преобразования типов для десериализации, хотя вы, вероятно, уже можете догадаться, как она выглядит:  

JSON | Python
------------- | -------------
объект  | dict
массив | list
строка | str
число (int) | int
число (float) | float
true | True
false | False
null | None  

Технически это преобразование не является в точности обратным к таблице сериализации, приведенной выше. В общем случае это означает, что если вы кодируете объект, а затем декодируете его позже, вы можете получить обратно не тот же самый объект.  
Самым простым примером этого будет кодирование данных в виде кортежа *tuple* и получение списка *list* после декодирования, например:  

	>>> blackjack_hand = (8, "Q")
	>>> encoded_hand = json.dumps(blackjack_hand)
	>>> decoded_hand = json.loads(encoded_hand)
	
	>>> blackjack_hand == decoded_hand
	False
	>>> type(blackjack_hand)
	<class 'tuple'>
	>>> type(decoded_hand)
	<class 'list'>
	>>> blackjack_hand == tuple(decoded_hand)
	True


### Простой пример десериализации данных  
На этот раз представьте, что у вас есть данные, хранящиеся на диске, которыми вы хотите манипулировать в памяти. Вы все также будете использовать диспетчер контекста, но на этот раз вы откроете существующий файл data_file.json в режиме чтения.  

	with open("data_file.json", "r") as read_file:
	    data = json.load(read_file)

Здесь все довольно просто, но имейте в виду, что результат выполнения этого кода может вернуть один из представленных выше типов данных из таблицы преобразования. Это важно, только если вы загружаете из файла данные, состав которых ранее вам был неизвестен ранее. В большинстве случаев корневой объект будет представлять собой словарь *dict* или список *list*.  
Если вы получаете данные JSON из другой программы или в случае получения строки форматированных данных JSON в Python, вы можете легко десериализовать это с помощью функции *load()*, которые просто загружаются из строки:  

	json_string = """
	{
	    "researcher": {
	        "name": "Ford Prefect",
	        "species": "Betelgeusian",
	        "relatives": [
	            {
	                "name": "Zaphod Beeblebrox",
	                "species": "Betelgeusian"
	            }
	        ]
	    }
	}
	"""
	data = json.loads(json_string)

### Пример (как бы) из реальной жизни ###

Для нашего примера мы будете использовать [JSONPlaceholder](https://jsonplaceholder.typicode.com/), отличный источник поддельных данных в формате JSON для отладки ваших приложений. Сначала создайте файл сценария с именем scratch.py ​​или любым другим.  
Вам нужно будет сформировать запрос *request* к служебному API [JSONPlaceholder](https://jsonplaceholder.typicode.com/), для этого проще использовать модуль [requests](http://docs.python-requests.org/en/master/), который проделает всю тяжелую работу за вас. Для этого добавьте эти объявления импорта *import* в начало файла:  

	import json
	import requests  

Теперь мы будем работать со списком [*TODO*](https://jsonplaceholder.typicode.com/todos), обращаясь к интерфейсу API [JSONPlaceholder](https://jsonplaceholder.typicode.com/) относительно входной точки */todos*. Если вы не знакомы с модулем [requests](http://docs.python-requests.org/en/master/), вы можете использовать еще один удобный метод *json()*, который будет выполнять всю вашу работу. Но мы будем практиковать использование модуля [json](https://docs.python.org/3/library/json.html) для десериализации атрибута *text* объекта ответа *response*, полученного при помощи [requests](http://docs.python-requests.org/en/master/). Это должно выглядеть примерно так:  

	response = requests.get("https://jsonplaceholder.typicode.com/todos")
	todos = json.loads(response.text)  

Вы не верите, что это работает? Хорошо, запустите файл в интерактивном режиме и протестируйте его самостоятельно. Пока вы делаете это, проверьте тип объекта *todos*. Загляните в элементы списка.  

	>>> todos == response.json()
	True
	>>> type(todos)
	<class 'list'>
	>>> todos[:10]
	...  

Вы можете увидеть структуру данных, посетив входную точку с помощью браузера, например так перейдя по ссылке [TODO](https://jsonplaceholder.typicode.com/todos):  

	{
	    "userId": 1,
	    "id": 1,
	    "title": "delectus aut autem",
	    "completed": false
	}  

Существует несколько пользователей, каждый из которых имеет уникальный идентификатор *userId*, каждая задача имеет свойство *complete* типа *Boolean*. Как можно определить, какие пользователи выполнили наибольшее количество задач? 

	# таблица userId спользователей полности выполнивших все задачи из TODO
	todos_by_user = {}
	
	# Подсчет количества задач из списка TODO выполненных каждым пользователем
	for todo in todos:
	    if todo["completed"]:
	        try:
	            # Суммируем (с помощью оператора инкремента) количество выполненных пользователем задач.
	            todos_by_user[todo["userId"]] += 1
	        except KeyError:
	            # Этот пользователь ничего не сделал. Зададим количество задач равным 1.
	            todos_by_user[todo["userId"]] = 1
	
	# Создадим сортированный список пар (userId, num_complete)
	top_users = sorted(todos_by_user.items(), 
	                   key=lambda x: x[1], reverse=True)
	
	# Зададим максимальное количество выполненных задач TODO в списке
	max_complete = top_users[0][1]
	
	# Создадим список list всех пользователей, которые имеют максимальное количество выполненных задач из TODO 
	users = []
	for user, num_complete in top_users:
	    if num_complete < max_complete:
	        break
	    users.append(str(user))
	
	max_users = " and ".join(users)  

Таким образом теперь мы можем манипулировать считанными из файла в формате JSON данными как обыкновенным объектом Python.
Когда мы запустим сценарий, то получим следующий результат:  

	>>> s = "s" if len(users) > 1 else ""
	>>> print(f"user{s} {max_users} completed {max_complete} TODOs")
	users 5 and 10 completed 12 TODOs
	# пользователи 5 и 10 выполнили 12 задач из TODO  

Для окончательного выполнения нашего задания создадим файл JSON, который будет содержать заполненные TODO для каждого из пользователей, которые завершили максимальное количество задач из TODO.   
Все, что вам нужно сделать, это отфильтровать задачи *todos* и записать полученный список в файл. Назовем выходной файл *filter_data_file.json*. Существует несколько способов, которым можно это сделать, но вот один из них:  

	# Определим функцию для фильтрации пользователей,
	# выполнивших максимальное количество заданий из TODO
	def keep(todo):
	    is_complete = todo["completed"]
	    has_max_count = todo["userId"] in users
	    return is_complete and has_max_count
	
	# Запишем отфильтрованные данные в файл
	with open("filtered_data_file.json", "w") as data_file:
	    filtered_todos = list(filter(keep, todos))
	    json.dump(filtered_todos, data_file, indent=2)

Отлично, мы сохранили нужные нам данные в файл, отфильтровав все ненужное. Запустите сценарий еще раз и проверьте файл *filter_data_file.json*, чтобы убедиться, что все работает как нам нужно. Он будет в том же каталоге, что и *scratch.py* ​​при его запуске.  


## Кодирование и декодирование пользовательских объектов Python ##  

Что происходит, когда мы пытаемся сериализовать класс *Elf* из приложения *Dungeons & Dragons*, над которым, например, вы работаете?  

	class Elf:
	    def __init__(self, level, ability_scores=None):
	        self.level = level
	        self.ability_scores = {
	            "str": 11, "dex": 12, "con": 10,
	            "int": 16, "wis": 14, "cha": 13
	        } if ability_scores is None else ability_scores
	        self.hp = 10 + self.ability_scores["con"]

Не удивительно, что Python жалуется, что Elf не может быть сериализован (*serializable*):

	>>> elf = Elf(level=4)
	>>> json.dumps(elf)
	TypeError: Object of type 'Elf' is not JSON serializable

Хотя модуль *json* может обрабатывать большинство встроенных типов данных Python, он не понимает, как по умолчанию кодировать сложные пользовательские типы данных. Это похоже на попытку поместить квадратный штифт в круглое отверстие.  

### Упрощение структур данных ###

Таким образом, теперь вопрос заключается в том, как работать с более сложными структурами данных. Ну, вы можете попытаться кодировать и декодировать JSON вручную, но есть более изящное решение, которое сэкономит ваше время работы. Вместо того, чтобы попытаться напрямую перейти от пользовательского типа данных к формату JSON, вы можете сделать это через промежуточный шаг.

Все, что вам нужно сделать, это представить ваши данные с точки зрения встроенных в Python типов данных, которые модуль *json* уже понимает. По сути, вы должны перевести сложный объект в более простое представление, которое модуль *json* затем трансформирует в JSON. Это похоже на транзитивное свойство отношений элементов в математике: если **A = B** и **B = C**, то **A = C**. 

Чтобы опробовать это, нам понадобится сложный объект для обработки. Вы можете использовать любой пользовательский класс, который вам нравится, но Python имеет встроенный тип, называемый [complex](https://www.mathsisfun.com/numbers/complex-numbers.html) для представления комплексных чисел, по умолчанию он не сериализуем. Итак, для этих примеров наш сложный объект будет иметь тип [complex](https://www.mathsisfun.com/numbers/complex-numbers.html).  

	>>> z = 3 + 8j
	>>> type(z)
	<class 'complex'>
	>>> json.dumps(z)
	TypeError: Object of type 'complex' is not JSON serializable


Хороший вопрос, который нужно задать себе при работе с пользовательскими типами данных. **Каков минимальный объем информации, необходим для воссоздания этого объекта?** В случае комплексных чисел вам нужно знать только значения реальных и мнимых частей числа, которые вы можете получить как атрибуты объекта типа [complex](https://www.mathsisfun.com/numbers/complex-numbers.html):  

	>>> z.real
	3.0
	>>> z.imag
	8.0

Передача тех же, что и в коде выше, чисел в конструктор *complex* достаточно, чтобы оператор сравнения *\__eq\__* вернул значение *True*:  

	>>> complex(3, 8) == z
	True

Разбиение пользовательских типов данных до их составляющих элементов имеет решающее значение как для процессов сериализации, так и для десериализации.

### Кодирование пользовательских типов данных ###
Для того чтобы перевести пользовательский объект в формат JSON, вам необходимо предусмотреть функцию кодирования для параметра *default* (по умолчанию) функции *dump()*. Модуль *json* будет вызывать эту функцию для любых объектов, которые не могут быть сериализованы нативным способом. Вот простая функция декодирования, которую вы можете использовать на практике:  

	def encode_complex(z):
	    if isinstance(z, complex):
	        return (z.real, z.imag)
	    else:
	        type_name = z.__class__.__name__
	        raise TypeError(f"Object of type '{type_name}' is not JSON serializable")  

Обратите внимание, что вы должны генерировать исключение TypeError, если вы не получите тот объект, который ожидаете. Теперь вы можете попробовать кодировать сложные объекты.  

	>>> json.dumps(9 + 5j, default=encode_complex)
	'[9.0, 5.0]'
	>>> json.dumps(elf, default=encode_complex)
	TypeError: Object of type 'Elf' is not JSON serializable

> **Почему мы кодировали комплексное число как кортеж *tuple*?** Хороший вопрос. Это, безусловно, не единственный и не лучший выбор. На самом деле, это было бы не очень хорошим представлением, если бы вы захотели позже декодировать объект и вы вскоре убедитесь в этом.

Другой общий подход заключается в применении подкласса стандартного *JSONEncoder* и переопределении его метода default()**:  

	class ComplexEncoder(json.JSONEncoder):
	    def default(self, z):
	        if isinstance(z, complex):
	            return (z.real, z.imag)
	        else:
	            super().default(self, z)

Вместо того, чтобы генерировать исключение типа TypeError самостоятельно, вы можете просто позволить базовому классу обработать его. Вы можете использовать это либо непосредственно в методе *dump()* через параметр *cls*, либо путем создания экземпляра кодера *encoder* и вызова его метода *encode()*:  

	>>> json.dumps(2 + 5j, cls=ComplexEncoder)
	'[2.0, 5.0]'
	
	>>> encoder = ComplexEncoder()
	>>> encoder.encode(3 + 6j)
	'[3.0, 6.0]'

### Декодирование пользовательских типов данных ###

Хотя реальные и мнимые части комплексного числа абсолютно необходимы, на самом деле их недостаточно для воссоздания объекта. Это происходит, когда вы пытаетесь кодировать комплексное число с помощью *ComplexEncoder* и затем декодируете результат:  

	>>> complex_json = json.dumps(4 + 17j, cls=ComplexEncoder)
	>>> json.loads(complex_json)
	[4.0, 17.0]

Вы получаете список *list*, и вам нужно будет передать значения в конструктор *complex*, если вы захотите снова создать объект комплексного числа. Напомним о нашей дискуссии о трудности декодирования выше. Отсутствуют метаданные или информация о типе данных, которые вы кодируете.
Я полагаю, что вопрос, который вы действительно должны задать себе - **Каков минимальный объем информации, который необходим и достаточен для воссоздания этого объекта?**

Модуль jso**n ожидает, что все пользовательские типы будут отображаться как объекты *objects* в стандарте форматирования JSON. Для разнообразия вы можете создать JSON-файл на этот раз с именем *complex_data.json* и добавить следующий объект *object*, представляющий комплексное число:

	{
	    "__complex__": true,
	    "real": 42,
	    "imag": 36
	}  

Этот ключ "*__complex__*" - это метаданные, о которых мы только что говорили ранее. На самом деле не имеет значения, с каким значением он ассоциирован. Чтобы этот маленький *хак* работал, все, что вам нужно сделать это проверить существует ли этот ключ:  

	def decode_complex(dct):
	    if "__complex__" in dct:
	        return complex(dct["real"], dct["imag"])
	    return dct

Если "*__complex__*" не находится в словаре, вы можете просто вернуть объект и разрешить декодировать декодером по умолчанию.  
Каждый раз, когда метод *load()* пытается проанализировать объект *object*, вам предоставляется возможность изменить его поведение перед тем, как дешифратор по умолчанию начнет работать с данными. Вы можете сделать это, передав вашу функцию декодирования через параметр *object_hook*.  
Запустим на выполнение следующий код:  

	>>> with open("complex_data.json") as complex_data:
	...     data = complex_data.read()
	...     z = json.loads(data, object_hook=decode_complex)
	... 
	>>> type(z)
	<class 'complex'>

Хотя параметр *object_hook* может показаться аналогичным *default*, параметру по умолчанию для  *dump()*, это не так.
Это работает не только с одним объектом. Попробуйте поместить список *list* комплексных чисел в *complex_data.json* и снова запустить скрипт:  

	[
	  {
	    "__complex__":true,
	    "real":42,
	    "imag":36
	  },
	  {
	    "__complex__":true,
	    "real":64,
	    "imag":11
	  }
	]

Если все пойдет хорошо, вы получите список объектов типа *complex*:

	>>> with open("complex_data.json") as complex_data:
	...     data = complex_data.read()
	...     numbers = json.loads(data, object_hook=decode_complex)
	... 
	>>> numbers
	[(42+36j), (64+11j)]  

Вы также можете попробовать использовать подкласс класса *JSONDecoder* и переопределить *object_hook*, но лучше всего придерживаться простого решения, когда это возможно.

## Все готово
Поздравляю теперь вы можете использовать всю мощь формата JSON для реализации ваших приложений на языке Python.  

Хотя примеры, с которыми мы работали здесь, безусловно, чрезмерно упрощены, они иллюстрируют рабочий процесс. Вы можете применить их к решению следующих задач:  

1. Импорт модуля *json*.  
2. Чтение данных с использованием функций *load()* или *loads()*.  
3. Обработка данных.  
4. Запись измененных данные с помощью функций *dump()* или *dumps()*.

То, что вы будете делать с данными после их загрузки в память, будет зависеть от конкретного варианта использования. Как правило, вашей целью будет получение данных из источника, извлечение полезной информации и передача информации далее или запись ее.  

Изучение стандартного модуля *json* делает проще изучение следующих модулей Python, использующихся для сериализации данных: [pickle](https://docs.python.org/3/library/pickle.html) и [marshal](https://docs.python.org/3/library/marshal.html).

Удачи всем в ваших будущих начинаниях при изучении  Python!



